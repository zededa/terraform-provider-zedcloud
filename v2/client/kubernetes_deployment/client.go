// Code generated by go-swagger; DO NOT EDIT.

package kubernetes_deployment

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new kubernetes deployments API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new kubernetes deployments API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new kubernetes deployments API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for kubernetes deployments API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateDeployment(params *CreateDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDeploymentOK, *CreateDeploymentCreated, error)

	DeleteDeployment(params *DeleteDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDeploymentOK, error)

	GetDeployment(params *GetDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDeploymentOK, error)

	ListDeployments(params *ListDeploymentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDeploymentsOK, error)

	UpdateDeployment(params *UpdateDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDeploymentOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	CreateDeployment creates a new kubernetes deployment

	Create a new Kubernetes deployment with Helm charts or other supported deployment types. This API supports both single-cluster and multi-cluster deployments.

**Example Request:**
```json

	{
	  "type": "HELMCHART",
	  "metadata": {
	    "name": "nginx-deployment",
	    "title": "NGINX Web Server",
	    "description": "Production NGINX deployment with custom configuration",
	    "project_id": "proj-12345"
	  },
	  "data": {
	    "helm_chart_data": {
	      "chart": {
	        "name": "nginx",
	        "version": "15.4.0",
	        "custom_values": {
	          "replicaCount": 3,
	          "service": {
	            "type": "LoadBalancer",
	            "port": 80
	          },
	          "ingress": {
	            "enabled": true,
	            "hosts": ["nginx.example.com"]
	          }
	        },
	        "repo_identifier": "bitnami"
	      },
	      "target_clusters": {
	        "is_multi_cluster": false,
	        "cluster_metadata": {
	          "cluster_id": "cluster-abc123",
	          "orchestrator_cluster_id": "rancher-cluster-123",
	          "cluster_name": "production-k8s",
	          "kube_version": "v1.28.0"
	        }
	      }
	    }
	  }
	}

```

**Example Response:**
```json

	{
	  "operationType": "OPS_TYPE_UNSPECIFIED",
	  "operationStatus": "OPS_STATUS_UNSPECIFIED",
	  "objectKind": "",
	  "objectId": "dep-abc123",
	  "objectName": "nginx-deployment",
	  "objectRevision": "",
	  "objectType": "OBJECT_TYPE_UNSPECIFIED",
	  "operationTime": "",
	  "startTime": "",
	  "endTime": "",
	  "user": "",
	  "httpStatusCode": 201,
	  "httpStatusMsg": "",
	  "jobId": "",
	  "error": [
	    {
	      "ec": "zMsgSucess",
	      "location": "",
	      "details": ""
	    }
	  ]
	}

```
*/
func (a *Client) CreateDeployment(params *CreateDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDeploymentOK, *CreateDeploymentCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateDeploymentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "_CreateDeployment",
		Method:             "POST",
		PathPattern:        "/v1/cluster/instances/kubernetes/deployments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateDeploymentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateDeploymentOK:
		return value, nil, nil
	case *CreateDeploymentCreated:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateDeploymentDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	DeleteDeployment deletes a deployment

	Delete a Kubernetes deployment and all its associated resources. This action is irreversible and will remove the deployment from all target clusters.

**Example Request:**
```
DELETE /v1/cluster/instances/kubernetes/deployments/id/dep-abc123
```

**Example Response:**
```json

	{
	  "operationType": "OPS_TYPE_UNSPECIFIED",
	  "operationStatus": "OPS_STATUS_UNSPECIFIED",
	  "objectKind": "",
	  "objectId": "dep-abc123",
	  "objectName": "nginx-deployment",
	  "objectRevision": "",
	  "objectType": "OBJECT_TYPE_UNSPECIFIED",
	  "operationTime": "",
	  "startTime": "",
	  "endTime": "",
	  "user": "",
	  "httpStatusCode": 200,
	  "httpStatusMsg": "",
	  "jobId": "",
	  "error": [
	    {
	      "ec": "zMsgSucess",
	      "location": "",
	      "details": ""
	    }
	  ]
	}

```

**Note:** The deployment_id parameter is **required** and must be a valid deployment identifier.
*/
func (a *Client) DeleteDeployment(params *DeleteDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDeploymentOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteDeploymentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "_DeleteDeployment",
		Method:             "DELETE",
		PathPattern:        "/v1/cluster/instances/kubernetes/deployments/id/{deploymentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteDeploymentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeleteDeploymentOK)
	if ok {
		return success, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteDeploymentDefault)

	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetDeployment gets deployment by ID

	Retrieve detailed information about a specific Kubernetes deployment including its current status, configuration, and metadata.

**Example Request:**
```
GET /v1/cluster/instances/kubernetes/deployments/id/dep-abc123
```

**Example Response:**
```json

	{
	  "id": "dep-abc123",
	  "name": "nginx-deployment",
	  "title": "NGINX Web Server",
	  "description": "Production NGINX deployment with custom configuration",
	  "project_id": "proj-12345",
	  "type": "HELMCHART",
	  "spec": {
	    "helm_chart_data": {
	      "chart": {
	        "name": "nginx",
	        "version": "15.4.0",
	        "custom_values": {
	          "replicaCount": 3,
	          "service": {
	            "type": "LoadBalancer",
	            "port": 80
	          }
	        },
	        "repo_identifier": "bitnami"
	      },
	      "target_clusters": {
	        "is_multi_cluster": false,
	        "cluster_metadata": {
	          "cluster_id": "cluster-abc123",
	          "cluster_name": "production-k8s"
	        }
	      }
	    }
	  },
	  "deployment_status": "Ready",
	  "created_at": "2024-01-15T10:30:00Z",
	  "updated_at": "2024-01-15T11:00:00Z",
	  "created_by": "user@example.com",
	  "updated_by": "user@example.com"
	}

```
*/
func (a *Client) GetDeployment(params *GetDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDeploymentOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetDeploymentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "_GetDeployment",
		Method:             "GET",
		PathPattern:        "/v1/cluster/instances/kubernetes/deployments/id/{deploymentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetDeploymentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetDeploymentOK)
	if ok {
		return success, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetDeploymentDefault)

	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListDeployments lists all deployments

	Retrieve a list of all Kubernetes deployments. Includes summary statistics and deployment status information.

**Example Request:**
```
GET /v1/cluster/instances/kubernetes/deployments
```

**Example Response:**
```json

	{
	  "total_count": 3,
	  "state_summary": {
	    "ready": 2,
	    "pending": 1,
	    "failed": 0
	  },
	  "deployments": [
	    {
	      "id": "dep-abc123",
	      "name": "nginx-deployment",
	      "title": "NGINX Web Server",
	      "description": "Production NGINX deployment",
	      "project_id": "proj-12345",
	      "type": "HELMCHART",
	      "deployment_status": "Ready",
	      "created_at": "2024-01-15T10:30:00Z",
	      "updated_at": "2024-01-15T11:00:00Z"
	    },
	    {
	      "id": "dep-def456",
	      "name": "redis-cache",
	      "title": "Redis Cache",
	      "description": "Redis caching layer",
	      "project_id": "proj-12345",
	      "type": "HELMCHART",
	      "deployment_status": "Ready",
	      "created_at": "2024-01-14T15:20:00Z",
	      "updated_at": "2024-01-14T15:25:00Z"
	    }
	  ]
	}

```
*/
func (a *Client) ListDeployments(params *ListDeploymentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDeploymentsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListDeploymentsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "_ListDeployments",
		Method:             "GET",
		PathPattern:        "/v1/cluster/instances/kubernetes/deployments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDeploymentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListDeploymentsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListDeploymentsDefault)

	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpdateDeployment updates a deployment

	Update an existing Kubernetes deployment configuration. This can include updating Helm chart values, changing target clusters, or modifying deployment metadata.

**Example Request:**
```
PUT /v1/cluster/instances/kubernetes/deployments/id/dep-abc123
```

```json

	{
	  "deployment_id": "dep-abc123",
	  "deployment_request": {
	    "type": "HELMCHART",
	    "metadata": {
	      "name": "nginx-deployment",
	      "title": "NGINX Web Server - Updated",
	      "description": "Updated NGINX deployment with SSL configuration",
	      "project_id": "proj-12345"
	    },
	    "data": {
	      "helm_chart_data": {
	        "chart": {
	          "name": "nginx",
	          "version": "15.5.0",
	          "custom_values": {
	            "replicaCount": 5,
	            "service": {
	              "type": "LoadBalancer",
	              "port": 80
	            },
	            "ingress": {
	              "enabled": true,
	              "hosts": ["nginx.example.com"],
	              "tls": {
	                "enabled": true,
	                "secretName": "nginx-tls"
	              }
	            }
	          },
	          "repo_identifier": "bitnami"
	        },
	        "target_clusters": {
	          "is_multi_cluster": false,
	          "cluster_metadata": {
	            "cluster_id": "cluster-abc123",
	            "orchestrator_cluster_id": "rancher-cluster-123",
	            "cluster_name": "production-k8s",
	            "kube_version": "v1.28.0"
	          }
	        }
	      }
	    }
	  }
	}

```

**Example Response:**
```json

	{
	  "operationType": "OPS_TYPE_UNSPECIFIED",
	  "operationStatus": "OPS_STATUS_UNSPECIFIED",
	  "objectKind": "",
	  "objectId": "dep-abc123",
	  "objectName": "nginx-deployment",
	  "objectRevision": "",
	  "objectType": "OBJECT_TYPE_UNSPECIFIED",
	  "operationTime": "",
	  "startTime": "",
	  "endTime": "",
	  "user": "",
	  "httpStatusCode": 200,
	  "httpStatusMsg": "",
	  "jobId": "",
	  "error": [
	    {
	      "ec": "zMsgSucess",
	      "location": "",
	      "details": ""
	    }
	  ]
	}

```
*/
func (a *Client) UpdateDeployment(params *UpdateDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateDeploymentOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateDeploymentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "_UpdateDeployment",
		Method:             "PUT",
		PathPattern:        "/v1/cluster/instances/kubernetes/deployments/id/{deploymentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateDeploymentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*UpdateDeploymentOK)
	if ok {
		return success, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UpdateDeploymentDefault)

	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
