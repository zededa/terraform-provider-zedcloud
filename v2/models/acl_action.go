// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ACLAction Acl action
//
// swagger:model AclAction
type ACLAction struct {

	// Not used by ZedUI
	//
	// Drop the packet
	Drop bool `json:"drop,omitempty"`

	// Limit action on ACL rule
	//
	// UI map: AppDetailsPage:EnvironmentsPane, AppDetailsPage:EnvironmentsPane
	Limit bool `json:"limit,omitempty"`

	// only valid if limit flag is set, see below.
	// Not used by ZedUI
	//
	// Value to be used for limit action (Required if limit is true)
	LimitValue *LimitParams `json:"limitValue,omitempty"`

	// Rate limit burst in ACL rule
	//
	// UI map: AppDetailsPage:EnvironmentsPane, AppDetailsPage:EnvironmentsPane
	Limitburst int64 `json:"limitburst,omitempty"`

	// Rate limit in ACL rule
	//
	// UI map: AppDetailsPage:EnvironmentsPane, AppDetailsPage:EnvironmentsPane
	Limitrate int64 `json:"limitrate,omitempty"`

	// Rate limit unit in ACL rule
	//
	// UI map: AppDetailsPage:EnvironmentsPane, AppDetailsPage:EnvironmentsPane
	Limitunit string `json:"limitunit,omitempty"`

	// Enable device to app port mapping for incoming ACL rule, implicitly added by ZedUI code
	//
	// UI map: AppDetailsPage:EnvironmentsPane, AppDetailsPage:EnvironmentsPane
	Portmap bool `json:"portmap,omitempty"`

	// Device to app port mapping for incoming ACL rule
	//
	// UI map: AppDetailsPage:EnvironmentsPane, AppDetailsPage:EnvironmentsPane
	Portmapto *MapParams `json:"portmapto,omitempty"`
}

// Validate validates this Acl action
func (m *ACLAction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLimitValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePortmapto(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ACLAction) validateLimitValue(formats strfmt.Registry) error {
	if swag.IsZero(m.LimitValue) { // not required
		return nil
	}

	if m.LimitValue != nil {
		if err := m.LimitValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("limitValue")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("limitValue")
			}
			return err
		}
	}

	return nil
}

func (m *ACLAction) validatePortmapto(formats strfmt.Registry) error {
	if swag.IsZero(m.Portmapto) { // not required
		return nil
	}

	if m.Portmapto != nil {
		if err := m.Portmapto.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("portmapto")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("portmapto")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this Acl action based on the context it is used
func (m *ACLAction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLimitValue(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePortmapto(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ACLAction) contextValidateLimitValue(ctx context.Context, formats strfmt.Registry) error {

	if m.LimitValue != nil {
		if err := m.LimitValue.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("limitValue")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("limitValue")
			}
			return err
		}
	}

	return nil
}

func (m *ACLAction) contextValidatePortmapto(ctx context.Context, formats strfmt.Registry) error {

	if m.Portmapto != nil {
		if err := m.Portmapto.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("portmapto")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("portmapto")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ACLAction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ACLAction) UnmarshalBinary(b []byte) error {
	var res ACLAction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
