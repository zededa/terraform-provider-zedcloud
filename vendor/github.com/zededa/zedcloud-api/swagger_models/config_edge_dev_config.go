// Copyright (c) 2018-2021 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

// Code generated by go-swagger; DO NOT EDIT.

package swagger_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ConfigEdgeDevConfig This is the response to a GET /api/v1/edgeDevice/config
// The EdgeDevConfig message carries all of the device's configuration from
// the controller to the device.
// The device will request these messages either periodically or as a result
// of some TBD notification.
// The message is assumed to be protected by a TLS session bound to the
// device certificate.
//
// swagger:model configEdgeDevConfig
type ConfigEdgeDevConfig struct {

	// apps
	Apps []*ConfigAppInstanceConfig `json:"apps"`

	// backup
	Backup *ConfigDeviceOpsCmd `json:"backup,omitempty"`

	// OBSOLETE - base. Use baseos instead. Controller should fill this for
	// backward compatibility till all the Older Eve images are no longer
	// supported.
	Base []*ConfigBaseOSConfig `json:"base"`

	// Baseos Config Block
	Baseos *ConfigBaseOS `json:"baseos,omitempty"`

	// controller supplies a list of cipher contexts,
	// containing certificate and other details, to be
	// used for sensitive data decryption
	CipherContexts []*ConfigCipherContext `json:"cipherContexts"`

	// config items
	ConfigItems []*ConfigConfigItem `json:"configItems"`

	// These images aka ContentTrees and Volumes should be created by EVE
	// independently of any application usage.
	// Application instances will refer to the volumes.
	ContentInfo []*ConfigContentTree `json:"contentInfo"`

	// controller_epoch indicates current epoch of config
	// if we set new epoch, EVE sends all info messages to controller
	// it captures when a new controller takes over and needs all the info be resent
	ControllerEpoch string `json:"controller_epoch,omitempty"`

	// This field is used by the device to detect when it needs to re-download
	// the controller certs using the /certs API endpoint.
	// The controller just needs to ensure this value changes when it wants the
	// device to re-fetch the controller certs, for instance by having it
	// be a hash of all of the controller certificates.
	ControllercertConfighash string `json:"controllercert_confighash,omitempty"`

	// datastores
	Datastores []*ConfigDatastoreConfig `json:"datastores"`

	// deviceIoList - List of Physical Adapters. Includes both Network
	//  Adapters and Non-Network Adapters ( USB / Com etc )
	DeviceIoList []*ConfigPhysicalIO `json:"deviceIoList"`

	// global_profile, if set, controls set of applications which will run.
	// The Activate=true app instances which have this profile in their profile_list
	// will run. If the global_profile is not set, then the profile_list is not
	// used to gate the application instances.
	GlobalProfile string `json:"global_profile,omitempty"`

	// id
	ID *ConfigUUIDandVersion `json:"id,omitempty"`

	// local_profile_server, if set, indicates a hostname/IPv4/IPv6 address and
	// optional port number at which EVE will request for a local profile.
	// If such a local profile is retrieved, it will override the global_profile.
	// The syntax follows the usual URL server name syntax thus the following
	// are example valid strings:
	//    [fe80::1]:1234
	//    10.1.1.1:1234
	//    hostname:1234
	//    [fe80::1]
	//    10.1.1.1
	//    hostname
	// If the port number is not specified, it will default to 8888
	LocalProfileServer string `json:"local_profile_server,omitempty"`

	// deprecated 23;
	// If maintence_mode is set the device will operate in a limited mode e.g.,
	// not start applications etc as to enable inspection of its state and
	// recover from bad state.
	MaintenanceMode bool `json:"maintenance_mode,omitempty"`

	// Override dmidecode info if set
	Manufacturer string `json:"manufacturer,omitempty"`

	// network instances
	NetworkInstances []*ConfigNetworkInstanceConfig `json:"networkInstances"`

	// networks
	Networks []*ConfigNetworkConfig `json:"networks"`

	// product name
	ProductName string `json:"productName,omitempty"`

	// Together with a local_profile_server one can specify a
	// profile_server_token. EVE must verify that the response from the
	// local_profile_server contains this token.
	ProfileServerToken string `json:"profile_server_token,omitempty"`

	// reboot
	Reboot *ConfigDeviceOpsCmd `json:"reboot,omitempty"`

	// systemAdapterList - List of DeviceNetworkAdapters. Only Network
	//  adapters ( Ex: eth0, wlan1 etc ) have a corresponding SystemAdapter.
	// non-Network adapters do not have systemadapters.
	SystemAdapterList []*ConfigSystemAdapter `json:"systemAdapterList"`

	// volumes
	Volumes []*ConfigVolume `json:"volumes"`
}

// Validate validates this config edge dev config
func (m *ConfigEdgeDevConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBaseos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCipherContexts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatastores(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeviceIoList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkInstances(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReboot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSystemAdapterList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConfigEdgeDevConfig) validateApps(formats strfmt.Registry) error {
	if swag.IsZero(m.Apps) { // not required
		return nil
	}

	for i := 0; i < len(m.Apps); i++ {
		if swag.IsZero(m.Apps[i]) { // not required
			continue
		}

		if m.Apps[i] != nil {
			if err := m.Apps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateBackup(formats strfmt.Registry) error {
	if swag.IsZero(m.Backup) { // not required
		return nil
	}

	if m.Backup != nil {
		if err := m.Backup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backup")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateBase(formats strfmt.Registry) error {
	if swag.IsZero(m.Base) { // not required
		return nil
	}

	for i := 0; i < len(m.Base); i++ {
		if swag.IsZero(m.Base[i]) { // not required
			continue
		}

		if m.Base[i] != nil {
			if err := m.Base[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("base" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateBaseos(formats strfmt.Registry) error {
	if swag.IsZero(m.Baseos) { // not required
		return nil
	}

	if m.Baseos != nil {
		if err := m.Baseos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("baseos")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateCipherContexts(formats strfmt.Registry) error {
	if swag.IsZero(m.CipherContexts) { // not required
		return nil
	}

	for i := 0; i < len(m.CipherContexts); i++ {
		if swag.IsZero(m.CipherContexts[i]) { // not required
			continue
		}

		if m.CipherContexts[i] != nil {
			if err := m.CipherContexts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cipherContexts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateConfigItems(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigItems) { // not required
		return nil
	}

	for i := 0; i < len(m.ConfigItems); i++ {
		if swag.IsZero(m.ConfigItems[i]) { // not required
			continue
		}

		if m.ConfigItems[i] != nil {
			if err := m.ConfigItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateContentInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentInfo) { // not required
		return nil
	}

	for i := 0; i < len(m.ContentInfo); i++ {
		if swag.IsZero(m.ContentInfo[i]) { // not required
			continue
		}

		if m.ContentInfo[i] != nil {
			if err := m.ContentInfo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateDatastores(formats strfmt.Registry) error {
	if swag.IsZero(m.Datastores) { // not required
		return nil
	}

	for i := 0; i < len(m.Datastores); i++ {
		if swag.IsZero(m.Datastores[i]) { // not required
			continue
		}

		if m.Datastores[i] != nil {
			if err := m.Datastores[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datastores" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateDeviceIoList(formats strfmt.Registry) error {
	if swag.IsZero(m.DeviceIoList) { // not required
		return nil
	}

	for i := 0; i < len(m.DeviceIoList); i++ {
		if swag.IsZero(m.DeviceIoList[i]) { // not required
			continue
		}

		if m.DeviceIoList[i] != nil {
			if err := m.DeviceIoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("deviceIoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if m.ID != nil {
		if err := m.ID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateNetworkInstances(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkInstances) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkInstances); i++ {
		if swag.IsZero(m.NetworkInstances[i]) { // not required
			continue
		}

		if m.NetworkInstances[i] != nil {
			if err := m.NetworkInstances[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkInstances" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateNetworks(formats strfmt.Registry) error {
	if swag.IsZero(m.Networks) { // not required
		return nil
	}

	for i := 0; i < len(m.Networks); i++ {
		if swag.IsZero(m.Networks[i]) { // not required
			continue
		}

		if m.Networks[i] != nil {
			if err := m.Networks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateReboot(formats strfmt.Registry) error {
	if swag.IsZero(m.Reboot) { // not required
		return nil
	}

	if m.Reboot != nil {
		if err := m.Reboot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reboot")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateSystemAdapterList(formats strfmt.Registry) error {
	if swag.IsZero(m.SystemAdapterList) { // not required
		return nil
	}

	for i := 0; i < len(m.SystemAdapterList); i++ {
		if swag.IsZero(m.SystemAdapterList[i]) { // not required
			continue
		}

		if m.SystemAdapterList[i] != nil {
			if err := m.SystemAdapterList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("systemAdapterList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this config edge dev config based on the context it is used
func (m *ConfigEdgeDevConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBase(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBaseos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCipherContexts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatastores(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeviceIoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkInstances(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReboot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemAdapterList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateApps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Apps); i++ {

		if m.Apps[i] != nil {
			if err := m.Apps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateBackup(ctx context.Context, formats strfmt.Registry) error {

	if m.Backup != nil {
		if err := m.Backup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backup")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateBase(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Base); i++ {

		if m.Base[i] != nil {
			if err := m.Base[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("base" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateBaseos(ctx context.Context, formats strfmt.Registry) error {

	if m.Baseos != nil {
		if err := m.Baseos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("baseos")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateCipherContexts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CipherContexts); i++ {

		if m.CipherContexts[i] != nil {
			if err := m.CipherContexts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cipherContexts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateConfigItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ConfigItems); i++ {

		if m.ConfigItems[i] != nil {
			if err := m.ConfigItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateContentInfo(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ContentInfo); i++ {

		if m.ContentInfo[i] != nil {
			if err := m.ContentInfo[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateDatastores(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Datastores); i++ {

		if m.Datastores[i] != nil {
			if err := m.Datastores[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datastores" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateDeviceIoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DeviceIoList); i++ {

		if m.DeviceIoList[i] != nil {
			if err := m.DeviceIoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("deviceIoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if m.ID != nil {
		if err := m.ID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateNetworkInstances(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkInstances); i++ {

		if m.NetworkInstances[i] != nil {
			if err := m.NetworkInstances[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkInstances" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateNetworks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Networks); i++ {

		if m.Networks[i] != nil {
			if err := m.Networks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateReboot(ctx context.Context, formats strfmt.Registry) error {

	if m.Reboot != nil {
		if err := m.Reboot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reboot")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateSystemAdapterList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SystemAdapterList); i++ {

		if m.SystemAdapterList[i] != nil {
			if err := m.SystemAdapterList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("systemAdapterList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConfigEdgeDevConfig) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConfigEdgeDevConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConfigEdgeDevConfig) UnmarshalBinary(b []byte) error {
	var res ConfigEdgeDevConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
