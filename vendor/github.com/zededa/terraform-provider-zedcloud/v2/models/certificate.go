// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Certificate certificate
//
// swagger:model Certificate
type Certificate struct {

	// This fields tells the basic constraints like isCA are correct.
	BasicContraintsValid bool `json:"basicContraintsValid,omitempty"`

	// certificate details
	//
	// base64 string of the parent certificate
	Cert string `json:"cert,omitempty"`

	// Crypto Key for decrypting user secret information
	CryptoKey string `json:"cryptoKey,omitempty"`

	// ECDSA encryption algorithm of the certificate
	EcdsaEncryption *ECDSA `json:"ecdsaEncryption,omitempty"`

	// secrets encryption
	//
	// user encrypted secrets map
	EncryptedSecrets map[string]string `json:"encryptedSecrets,omitempty"`

	// Indicates if the private key can be exported.
	Exportable bool `json:"exportable,omitempty"`

	// Sequence of extended key usages.
	ExtendedKeyUsage []string `json:"extendedKeyUsage"`

	// Parameters for the issuer of the X509 component of a certificate.
	Issuer *Subject `json:"issuer,omitempty"`

	// Key usage extensions define the purpose of the public key contained in a certificate.
	KeyUsage int32 `json:"keyUsage,omitempty"`

	// pass phase for the pvt key, this has to be filled if pvt key is encrypted with a pass phrase
	PassPhrase string `json:"passPhrase,omitempty"`

	// base63 string of the public key
	PublicKey string `json:"publicKey,omitempty"`

	// encryption algorithm
	//
	// Public key algorithm.
	PublicKeyAlgorithm string `json:"publicKeyAlgorithm,omitempty"`

	// base64 string of the parent pvt key
	PvtKey string `json:"pvtKey,omitempty"`

	// Indicates if the same key pair will be used on certificate renewal.
	ReuseKey bool `json:"reuseKey,omitempty"`

	// RSA encryption algorithm of the certificate
	RsaEcryption *RSA `json:"rsaEcryption,omitempty"`

	// Subject alternative name values
	//
	// This holds the alternative name values like URIs, domain names IPs etc.
	SanValues *SANValues `json:"sanValues,omitempty"`

	// Unique identifier for each Certificate generated by an Certificate Issuer.
	SerialNumber string `json:"serialNumber,omitempty"`

	// signature algorithm
	SignatureAlgorithm string `json:"signatureAlgorithm,omitempty"`

	// Parameters for the subject of the X509 component of a certificate.
	Subject *Subject `json:"subject,omitempty"`

	// certificate validity
	//
	// Certificate validatity start time
	// Format: date-time
	ValidFrom strfmt.DateTime `json:"validFrom,omitempty"`

	// Certificate validatity start time
	// Format: date-time
	ValidTill strfmt.DateTime `json:"validTill,omitempty"`
}

// Validate validates this certificate
func (m *Certificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEcdsaEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRsaEcryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSanValues(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidTill(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Certificate) validateEcdsaEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.EcdsaEncryption) { // not required
		return nil
	}

	if m.EcdsaEncryption != nil {
		if err := m.EcdsaEncryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ecdsaEncryption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ecdsaEncryption")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(m.Issuer) { // not required
		return nil
	}

	if m.Issuer != nil {
		if err := m.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuer")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) validateRsaEcryption(formats strfmt.Registry) error {
	if swag.IsZero(m.RsaEcryption) { // not required
		return nil
	}

	if m.RsaEcryption != nil {
		if err := m.RsaEcryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rsaEcryption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rsaEcryption")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) validateSanValues(formats strfmt.Registry) error {
	if swag.IsZero(m.SanValues) { // not required
		return nil
	}

	if m.SanValues != nil {
		if err := m.SanValues.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sanValues")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sanValues")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) validateSubject(formats strfmt.Registry) error {
	if swag.IsZero(m.Subject) { // not required
		return nil
	}

	if m.Subject != nil {
		if err := m.Subject.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subject")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subject")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) validateValidFrom(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidFrom) { // not required
		return nil
	}

	if err := validate.FormatOf("validFrom", "body", "date-time", m.ValidFrom.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Certificate) validateValidTill(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidTill) { // not required
		return nil
	}

	if err := validate.FormatOf("validTill", "body", "date-time", m.ValidTill.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this certificate based on the context it is used
func (m *Certificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEcdsaEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRsaEcryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSanValues(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Certificate) contextValidateEcdsaEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.EcdsaEncryption != nil {
		if err := m.EcdsaEncryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ecdsaEncryption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ecdsaEncryption")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if m.Issuer != nil {
		if err := m.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuer")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) contextValidateRsaEcryption(ctx context.Context, formats strfmt.Registry) error {

	if m.RsaEcryption != nil {
		if err := m.RsaEcryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rsaEcryption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rsaEcryption")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) contextValidateSanValues(ctx context.Context, formats strfmt.Registry) error {

	if m.SanValues != nil {
		if err := m.SanValues.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sanValues")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sanValues")
			}
			return err
		}
	}

	return nil
}

func (m *Certificate) contextValidateSubject(ctx context.Context, formats strfmt.Registry) error {

	if m.Subject != nil {
		if err := m.Subject.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subject")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subject")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Certificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Certificate) UnmarshalBinary(b []byte) error {
	var res Certificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
