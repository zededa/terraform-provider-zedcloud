{
    "swagger": "2.0",
    "info": {
        "title": "ZEDEDA Diagnostics Service",
        "description": "ZEDEDA Diagnostics Service is a helper service that provides insight into two things - cloud diagnostics data and edge diagnostics data. As part of Cloud Diagnostics, it allows insight into zedcontrol cluster. As part of Edge Diagnisticss, it collects monitoring data from the edge nodes and presents an aggregated timeline view of resource usage and health of edge nodes",
        "termsOfService": "https://www.zededa.com/terms",
        "version": "1.0",
        "contact": {
            "name": "ZEDEDA API Support",
            "url": "https://www.zededa.com/support",
            "email": "support@zededa.com"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        }
    },
    "tags": [
        {
            "name": "CloudDiagnostics"
        },
        {
            "name": "EdgeDiagnostics"
        }
    ],
    "basePath": "/api",
    "schemes": [
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "paths": {
        "/v1/cloud/healthreport": {
            "get": {
                "summary": "Get Cloud services health report",
                "description": "Get Cloud services health report.",
                "operationId": "CloudDiagnostics_GetClusterHealthReport",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/HealthServiceResp"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                },
                "parameters": [
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ]
            }
        },
        "/v1/cloud/ping": {
            "get": {
                "summary": "Check Cloud reachability",
                "description": "Check Cloud reachability by sending a ping message to API gateway. API gateway will echo back either \"pong\" or the id specified.",
                "operationId": "CloudDiagnostics_checkClusterHealth",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/PingMsgSendResp"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "pingId",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "format": "int64"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/cloud/ping/id/{pingId}": {
            "get": {
                "summary": "Check Cloud reachability",
                "description": "Check Cloud reachability by sending a ping message to API gateway. API gateway will echo back either \"pong\" or the id specified.",
                "operationId": "CloudDiagnostics_checkClusterHealth2",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/PingMsgSendResp"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "pingId",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "format": "int64"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/cloud/policies": {
            "get": {
                "summary": "Query Cloud policies",
                "description": "Query policy records of latest version of Cloud policies.",
                "operationId": "CloudDiagnostics_QueryCloudPolicies",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/PolicyDocVersionResp"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "all",
                        "in": "query",
                        "required": false,
                        "type": "boolean"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            },
            "post": {
                "summary": "Create Cloud policy document",
                "description": "Create policy document",
                "operationId": "CloudDiagnostics_CreateCloudPolicyDocument",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/PolicyDocVersionResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/PolicyDocVersion"
                        }
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/cloud/policies/id/{id}": {
            "get": {
                "summary": "Get Cloud policy document",
                "description": "Get policy document for specific version of Cloud policy.",
                "operationId": "CloudDiagnostics_GetCloudPolicyDocument",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/PolicyDocVersionResp"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            },
            "delete": {
                "summary": "Delete Cloud policy specific version",
                "description": "Delete policy record for specific version of Cloud policy.",
                "operationId": "CloudDiagnostics_DeleteCloudPolicyDocument",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/PolicyDocVersionResp"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/cloud/policies/latest": {
            "put": {
                "summary": "Update Cloud policy specific version",
                "description": "Update Cloud policy specific version",
                "operationId": "CloudDiagnostics_MarkCloudPolicyLatest",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/PolicyDocVersionResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/PolicyDocVersion"
                        }
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/cloud/version": {
            "get": {
                "summary": "Get Cloud controller software version",
                "description": "Get Cloud controller software version.",
                "operationId": "CloudDiagnostics_GetClusterVersion",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/CloudVersionResp"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                },
                "parameters": [
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ]
            }
        },
        "/v1/devices/id/{id}/config": {
            "get": {
                "summary": "Get current Device twin configuration",
                "description": "Get currentnext Device twin configuration for the edge node. Edge node has read this configuration when it queried Cloud controller last time.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinConfig",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "description": "system generated unique id for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            },
            "put": {
                "summary": "Re-generate device configuration",
                "description": "Re-generate the device configuration. Edge node will get this configuration when it queries Cloud controller next time.",
                "operationId": "EdgeDiagnostics_RegenDeviceConfig",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "description": "system generated unique id for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/devices/id/{id}/config/bootstrap": {
            "get": {
                "summary": "Get bootstrap Device twin configuration",
                "description": "Get bootstrap Device twin configuration for the edge node. Doesn't change the existing edge node configuration.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinBootstrapConfig",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "405": {
                        "description": "Method not allowed. The API request can't be performed due to a wrong edge node's admin status.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "description": "system generated unique id for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/devices/id/{id}/config/next": {
            "get": {
                "summary": "Get next Device twin configuration",
                "description": "Get next Device twin configuration for the edge node. Edge node will get this configuration when it queries Cloud controller next time.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinNextConfig",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "description": "system generated unique id for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/devices/id/{id}/config/offline": {
            "get": {
                "summary": "Get offline Device twin configuration",
                "description": "Get offline Device twin configuration for the edge node. Edge node will get this configuration when it queries Cloud controller next time.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinOfflineNextConfig",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "description": "system generated unique id for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/devices/name/{name}/config": {
            "get": {
                "summary": "Get current Device twin configuration",
                "description": "Get currentnext Device twin configuration for the edge node. Edge node has read this configuration when it queried Cloud controller last time.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinConfigByName",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "user defined device name for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/devices/name/{name}/config/bootstrap": {
            "get": {
                "summary": "Get bootstrap Device twin configuration",
                "description": "Get bootstrap Device twin configuration for the edge node. Doesn't change the existing edge node configuration.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinBootstrapConfigByName",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "405": {
                        "description": "Method not allowed. The API request can't be performed due to a wrong edge node's admin status.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "user defined device name for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/devices/name/{name}/config/next": {
            "get": {
                "summary": "Get next Device twin configuration",
                "description": "Get next Device twin configuration for the edge node. Edge node will get this configuration when it queries Cloud controller next time.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinNextConfigByName",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "user defined device name for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/devices/name/{name}/config/offline": {
            "get": {
                "summary": "Get offline Device twin configuration",
                "description": "Get offline Device twin configuration for the edge node. Edge node will get this configuration when it queries Cloud controller next time.",
                "operationId": "EdgeDiagnostics_GetDeviceTwinOfflineConfigByName",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/ConfigServiceResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-node level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found. The API gateway did not process the request because the requested resource could not be found.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "user defined device name for a device",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/events": {
            "get": {
                "summary": "Get events timeline",
                "description": "Get aggregated events timeline",
                "operationId": "EdgeDiagnostics_GetEventsTimeline",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/EventQueryResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-app level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "objname",
                        "description": "Object name",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "objid",
                        "description": "Object id",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "objtype",
                        "description": "Object type",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "UNSPECIFIED",
                            "USER",
                            "EDGE_NODE",
                            "EDGE_APP",
                            "IMAGE",
                            "EDGE_APP_INSTANCE",
                            "PROJECT",
                            "NETWORK",
                            "DATASTORE",
                            "SERVICE",
                            "SERVICE_INSTANCE",
                            "ENTERPRISE",
                            "ROLE",
                            "CREDENTIAL",
                            "NETWORK_INSTANCE",
                            "VOLUME_INSTANCE",
                            "REALM",
                            "AUTHPROFILE",
                            "POLICY",
                            "APP_POLICY",
                            "CLUSTER_INSTANCE",
                            "PLUGIN",
                            "DOC_POLICY",
                            "ORCHESTRATOR_CLUSTER",
                            "TAGS",
                            "EDGE_NODE_INTERFACE",
                            "DEPLOYMENT",
                            "ENTITLEMENTS",
                            "DATA_STREAM",
                            "API_USAGE",
                            "APP_INSTANCE_SNAPSHOT"
                        ],
                        "default": "UNSPECIFIED"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/events/timeSeries/{mType}": {
            "get": {
                "summary": "Get resource usage timeline",
                "description": "Get the aggregated resource usage timeline as reported by the edge nodes and edge application instances.",
                "operationId": "EdgeDiagnostics_GetResourceMetricsTimeline",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/MetricQueryResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-app level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "mType",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "enum": [
                            "METRIC_TYPE_UNSPECIFIED",
                            "METRIC_TYPE_CPU_TOTAL",
                            "METRIC_TYPE_CPU_USAGE",
                            "METRIC_TYPE_MEMORY_TOTAL",
                            "METRIC_TYPE_MEMORY_UTILIZATION",
                            "METRIC_TYPE_NETWORK_TOTAL",
                            "METRIC_TYPE_NETWORK_RATES",
                            "METRIC_TYPE_EVENTS_COUNT",
                            "METRIC_TYPE_STORAGE_UTILIZATION",
                            "METRIC_TYPE_STORAGE_IO_ZPOOL",
                            "METRIC_TYPE_STORAGE_IO_ZVOL"
                        ]
                    },
                    {
                        "name": "objtype",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "OBJECT_TYPE_UNSPECIFIED",
                            "OBJECT_TYPE_USER",
                            "OBJECT_TYPE_EDGE_NODE",
                            "OBJECT_TYPE_EDGE_APP",
                            "OBJECT_TYPE_IMAGE",
                            "OBJECT_TYPE_EDGE_APP_INSTANCE",
                            "OBJECT_TYPE_PROJECT",
                            "OBJECT_TYPE_NETWORK",
                            "OBJECT_TYPE_DATASTORE",
                            "OBJECT_TYPE_SERVICE",
                            "OBJECT_TYPE_SERVICE_INSTANCE",
                            "OBJECT_TYPE_ENTERPRISE",
                            "OBJECT_TYPE_ROLE",
                            "OBJECT_TYPE_CREDENTIAL",
                            "OBJECT_TYPE_NETWORK_INSTANCE",
                            "OBJECT_TYPE_VOLUME_INSTANCE",
                            "OBJECT_TYPE_REALM",
                            "OBJECT_TYPE_AUTHPROFILE",
                            "OBJECT_TYPE_POLICY",
                            "OBJECT_TYPE_APP_POLICY",
                            "OBJECT_TYPE_CLUSTER_INSTANCE",
                            "OBJECT_TYPE_PLUGIN",
                            "OBJECT_TYPE_DOC_POLICY",
                            "OBJECT_TYPE_ORCHESTRATOR_CLUSTER",
                            "OBJECT_TYPE_TAGS",
                            "OBJECT_TYPE_EDGE_NODE_INTERFACE",
                            "OBJECT_TYPE_DEPLOYMENT",
                            "OBJECT_TYPE_ENTITLEMENTS",
                            "OBJECT_TYPE_DATA_STREAM",
                            "OBJECT_TYPE_API_USAGE",
                            "OBJECT_TYPE_APP_INSTANCE_SNAPSHOT",
                            "OBJECT_TYPE_PATCH_ENVELOPE",
                            "OBJECT_TYPE_RESOURCE_USAGE_TRACK",
                            "OBJECT_TYPE_PATCH_ENVELOPE_REFERENCE",
                            "OBJECT_TYPE_DEV_PASSTHROUGH",
                            "OBJECT_TYPE_EDGE_NODE_CLUSTER",
                            "OBJECT_TYPE_ASSET_GROUP",
                            "OBJECT_TYPE_APP_PROFILE",
                            "OBJECT_TYPE_PROFILE_DEPLOYMENT",
                            "OBJECT_TYPE_ZKS_INSTANCE",
                            "OBJECT_TYPE_CLUSTER_GROUP"
                        ],
                        "default": "OBJECT_TYPE_UNSPECIFIED"
                    },
                    {
                        "name": "objname",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "startTime",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "endTime",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "interval",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "enterpriseId",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "objid",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/events/topUsers": {
            "get": {
                "summary": "Get top users",
                "description": "Get top users.",
                "operationId": "EdgeDiagnostics_GetTopUsers2",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/EventTopUsersResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-app level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                },
                "parameters": [
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ]
            }
        },
        "/v1/hello": {
            "post": {
                "summary": "Check Cloud services health",
                "description": "Check Cloud services health by sending a hello name to microservice behind API Gateway. Microservice will echo back the name.",
                "operationId": "CloudDiagnostics_checkMicroserviceHealth",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/HelloResp"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/HelloName"
                        }
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "CloudDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        },
        "/v1/timeSeries/{mType}": {
            "get": {
                "summary": "Get resource usage timeline",
                "description": "Get the aggregated resource usage timeline as reported by the edge nodes and edge application instances.",
                "operationId": "EdgeDiagnostics_GetResourceMetricsTimeline2",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/MetricQueryResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request. The API gateway did not process the request because of missing parameter or invalid value of parameters.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized. The API gateway did not process the request because it lacks valid authentication credentials for the target resource. The request header has either no authorization details or an authorization that has been refused.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden. The API gateway did not process the request because the requestor does not have edge-app level access permission for the operation or does not have access scope to the project.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error. The API gateway experienced an unexpected condition. Specific error condition is indicated in error codes.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout. The API gateway did not receive a timely response from an upstream microservice it needed to communicate with in order to complete the request.",
                        "schema": {
                            "$ref": "#/definitions/ZsrvResponse"
                        }
                    },
                    "default": {
                        "description": "An unexpected error response.",
                        "schema": {
                            "$ref": "#/definitions/googlerpcStatus"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "mType",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "enum": [
                            "METRIC_TYPE_UNSPECIFIED",
                            "METRIC_TYPE_CPU_TOTAL",
                            "METRIC_TYPE_CPU_USAGE",
                            "METRIC_TYPE_MEMORY_TOTAL",
                            "METRIC_TYPE_MEMORY_UTILIZATION",
                            "METRIC_TYPE_NETWORK_TOTAL",
                            "METRIC_TYPE_NETWORK_RATES",
                            "METRIC_TYPE_EVENTS_COUNT",
                            "METRIC_TYPE_STORAGE_UTILIZATION",
                            "METRIC_TYPE_STORAGE_IO_ZPOOL",
                            "METRIC_TYPE_STORAGE_IO_ZVOL"
                        ]
                    },
                    {
                        "name": "objtype",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "OBJECT_TYPE_UNSPECIFIED",
                            "OBJECT_TYPE_USER",
                            "OBJECT_TYPE_EDGE_NODE",
                            "OBJECT_TYPE_EDGE_APP",
                            "OBJECT_TYPE_IMAGE",
                            "OBJECT_TYPE_EDGE_APP_INSTANCE",
                            "OBJECT_TYPE_PROJECT",
                            "OBJECT_TYPE_NETWORK",
                            "OBJECT_TYPE_DATASTORE",
                            "OBJECT_TYPE_SERVICE",
                            "OBJECT_TYPE_SERVICE_INSTANCE",
                            "OBJECT_TYPE_ENTERPRISE",
                            "OBJECT_TYPE_ROLE",
                            "OBJECT_TYPE_CREDENTIAL",
                            "OBJECT_TYPE_NETWORK_INSTANCE",
                            "OBJECT_TYPE_VOLUME_INSTANCE",
                            "OBJECT_TYPE_REALM",
                            "OBJECT_TYPE_AUTHPROFILE",
                            "OBJECT_TYPE_POLICY",
                            "OBJECT_TYPE_APP_POLICY",
                            "OBJECT_TYPE_CLUSTER_INSTANCE",
                            "OBJECT_TYPE_PLUGIN",
                            "OBJECT_TYPE_DOC_POLICY",
                            "OBJECT_TYPE_ORCHESTRATOR_CLUSTER",
                            "OBJECT_TYPE_TAGS",
                            "OBJECT_TYPE_EDGE_NODE_INTERFACE",
                            "OBJECT_TYPE_DEPLOYMENT",
                            "OBJECT_TYPE_ENTITLEMENTS",
                            "OBJECT_TYPE_DATA_STREAM",
                            "OBJECT_TYPE_API_USAGE",
                            "OBJECT_TYPE_APP_INSTANCE_SNAPSHOT",
                            "OBJECT_TYPE_PATCH_ENVELOPE",
                            "OBJECT_TYPE_RESOURCE_USAGE_TRACK",
                            "OBJECT_TYPE_PATCH_ENVELOPE_REFERENCE",
                            "OBJECT_TYPE_DEV_PASSTHROUGH",
                            "OBJECT_TYPE_EDGE_NODE_CLUSTER",
                            "OBJECT_TYPE_ASSET_GROUP",
                            "OBJECT_TYPE_APP_PROFILE",
                            "OBJECT_TYPE_PROFILE_DEPLOYMENT",
                            "OBJECT_TYPE_ZKS_INSTANCE",
                            "OBJECT_TYPE_CLUSTER_GROUP"
                        ],
                        "default": "OBJECT_TYPE_UNSPECIFIED"
                    },
                    {
                        "name": "objname",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "startTime",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "endTime",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "interval",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "name": "enterpriseId",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "objid",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "X-Request-Id",
                        "in": "header",
                        "required": false,
                        "description": "User-Agent specified id to track a request",
                        "type": "string"
                    }
                ],
                "tags": [
                    "EdgeDiagnostics"
                ],
                "externalDocs": {
                    "description": "ZEDEDA Product Documentation",
                    "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
                }
            }
        }
    },
    "definitions": {
        "BriefHealth": {
            "type": "object",
            "properties": {
                "serviceHealthStatus": {
                    "type": "string"
                }
            }
        },
        "CloudVersion": {
            "type": "object",
            "properties": {
                "comp": {
                    "type": "string"
                },
                "ver": {
                    "type": "string"
                }
            }
        },
        "CloudVersionResp": {
            "type": "object",
            "properties": {
                "version": {
                    "$ref": "#/definitions/CloudVersion"
                },
                "result": {
                    "$ref": "#/definitions/ZsrvResponse"
                }
            }
        },
        "CmdArg": {
            "type": "object",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Command line argument: key"
                },
                "value": {
                    "type": "string",
                    "description": "Command line argument: value"
                }
            },
            "description": "CmdArg store the passed command line key and values",
            "title": "CmdArg is used to store the command line arguments"
        },
        "ConfigServiceResp": {
            "type": "object",
            "properties": {
                "config": {
                    "$ref": "#/definitions/configEdgeDevConfig"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time"
                },
                "readAt": {
                    "type": "string",
                    "format": "date-time"
                },
                "result": {
                    "$ref": "#/definitions/ZsrvResponse"
                },
                "lastKnownStatus": {
                    "$ref": "#/definitions/LastKnownStatus"
                },
                "pconfig": {
                    "type": "string",
                    "title": "protobuf stringified"
                },
                "nextConfig": {
                    "$ref": "#/definitions/configEdgeDevConfig",
                    "title": "Next config (config which available for the device, but is not yet pushed to the device)\nLatest config (config which is generated, but not allowed to be pushed to the device due to config lock configured on the device)"
                },
                "nextConfigHash": {
                    "type": "string"
                },
                "latestConfig": {
                    "$ref": "#/definitions/configEdgeDevConfig"
                },
                "latestConfigHash": {
                    "type": "string"
                },
                "localOperatorConsoleBlobList": {
                    "$ref": "#/definitions/LocalOperatorConsoleBlobList",
                    "title": "Local Operator Console Blob Config"
                }
            },
            "title": "Edge Device Configuration Response to CLI/UI routed via Kafka"
        },
        "Cursor": {
            "type": "object",
            "properties": {
                "pageToken": {
                    "type": "string",
                    "description": "Page Token"
                },
                "orderBy": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "OrderBy helps in sorting the list response"
                },
                "pageNum": {
                    "type": "number",
                    "format": "int64",
                    "description": "Page Number"
                },
                "pageSize": {
                    "type": "number",
                    "format": "int64",
                    "description": "Defines the page size"
                },
                "totalPages": {
                    "type": "number",
                    "format": "int64",
                    "description": "Total number of pages to be fetched."
                }
            },
            "description": "Cursor helps in filtering the various list response like edge-app bundle list, model list, bundle list etc. ",
            "title": "Cursor is used as filter in list operation."
        },
        "DebugKnobDetail": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "system generated unique id for a device",
                    "readOnly": true,
                    "pattern": "[0-9A-Za-z-]+"
                },
                "debugKnob": {
                    "type": "boolean",
                    "description": "debug knob flag"
                },
                "expiry": {
                    "type": "string",
                    "format": "uint64",
                    "description": "debug expiry time in minutes"
                },
                "expired": {
                    "type": "boolean",
                    "description": "debug knob expiry status flag"
                }
            },
            "description": "Device debug knob configuration request payload holds the device debug mode properties",
            "title": "Device debug knob configuration"
        },
        "DeviceCmdsSubType": {
            "type": "string",
            "enum": [
                "DeviceNoOp",
                "DeviceStart",
                "DeviceStop",
                "DeviceReboot",
                "DeviceShutdown",
                "DeviceUpdateOS",
                "DeviceApplyOS",
                "DeviceReset",
                "DeviceAddOS",
                "DeviceDropOS",
                "DeviceOffboard",
                "DeviceActivate",
                "DeviceDeActivate",
                "DeviceBaseosRetry",
                "DeviceStartDebugMode",
                "DeviceStopDebugMode",
                "PreparePowerOff",
                "DeviceStartEdgeviewMode",
                "DeviceStopEdgeviewMode",
                "DeviceEdgeviewClientScript"
            ],
            "default": "DeviceNoOp",
            "description": " - DeviceNoOp: Device Operation: No Operation\n - DeviceStart: Device Operation: Start\n - DeviceStop: Device Operation: Stop\n - DeviceReboot: Device Operation: Reboot: Power cycle the device\n - DeviceShutdown: Device Operation: Shutdown- Power off the device\n - DeviceUpdateOS: Device Operation: Update OS- deprecated\n - DeviceApplyOS: Device Operation: Apply OS- Change Boot order of installed images\n - DeviceReset: Device Operation: Reset- Config reset to factory default\n - DeviceAddOS: Device Operation: Add OS- Install new image but don't change boot order\n - DeviceDropOS: Device Operation: Drop OS- Remove uninstalled image but don't change boot order\n - DeviceOffboard: Device Operation Type: offboard the device\n - DeviceActivate: Device Activate\n - DeviceDeActivate: Device Deactivate\n - DeviceBaseosRetry: Device Operation: Retry OS\n - DeviceStartDebugMode: Device Operation: Run device in debug mode.\n - DeviceStopDebugMode: Device Operation: Stop device in debug mode.\n - PreparePowerOff: Device Operation: Gracefully shutdown all apps and prepare for power down.\n - DeviceStartEdgeviewMode: Device Operation: Run device in edgeview mode.\n - DeviceStopEdgeviewMode: Device Operation: Stop device in edgeview mode.\n - DeviceEdgeviewClientScript: Device Operation: get Edgeview client script if activated."
        },
        "EventQueryRequestWithType_HttpRequestObjectType_HttpRequest": {
            "type": "string",
            "enum": [
                "UNSPECIFIED",
                "USER",
                "EDGE_NODE",
                "EDGE_APP",
                "IMAGE",
                "EDGE_APP_INSTANCE",
                "PROJECT",
                "NETWORK",
                "DATASTORE",
                "SERVICE",
                "SERVICE_INSTANCE",
                "ENTERPRISE",
                "ROLE",
                "CREDENTIAL",
                "NETWORK_INSTANCE",
                "VOLUME_INSTANCE",
                "REALM",
                "AUTHPROFILE",
                "POLICY",
                "APP_POLICY",
                "CLUSTER_INSTANCE",
                "PLUGIN",
                "DOC_POLICY",
                "ORCHESTRATOR_CLUSTER",
                "TAGS",
                "EDGE_NODE_INTERFACE",
                "DEPLOYMENT",
                "ENTITLEMENTS",
                "DATA_STREAM",
                "API_USAGE",
                "APP_INSTANCE_SNAPSHOT"
            ],
            "default": "UNSPECIFIED"
        },
        "EventQueryResponse": {
            "type": "object",
            "properties": {
                "list": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/EventQueryResponseItem"
                    },
                    "description": "Event Query response list"
                },
                "next": {
                    "type": "object",
                    "$ref": "#/definitions/Cursor",
                    "description": "Cursor filter"
                },
                "summary": {
                    "$ref": "#/definitions/Summary",
                    "description": "Summary of filtered events."
                }
            },
            "description": "Event query response request payload",
            "title": "Event query Response payload detail",
            "required": [
                "list",
                "next"
            ]
        },
        "EventQueryResponseItem": {
            "type": "object",
            "properties": {
                "user": {
                    "type": "string",
                    "description": "User name"
                },
                "project": {
                    "type": "string",
                    "description": "project name"
                },
                "device": {
                    "type": "string",
                    "description": "device name"
                },
                "instance": {
                    "type": "string",
                    "description": "instance name"
                },
                "severity": {
                    "type": "string",
                    "description": "severity: FIXME: should be ENUM"
                },
                "description": {
                    "type": "string",
                    "description": "Event description"
                },
                "timestamp": {
                    "type": "object",
                    "format": "date-time",
                    "description": "event timestamp"
                },
                "source": {
                    "type": "object",
                    "$ref": "#/definitions/EventSource",
                    "description": "source"
                },
                "resource": {
                    "type": "string",
                    "description": "Event resources"
                },
                "eventType": {
                    "type": "string",
                    "description": "Event type"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Event tags"
                },
                "resourceName": {
                    "type": "string",
                    "description": "Event resources"
                },
                "jsonData": {
                    "type": "object",
                    "description": "Event resources"
                },
                "clusterInstance": {
                    "type": "string",
                    "description": "clusterInstance name"
                }
            },
            "description": "Event query response item payload",
            "title": "Event query response item payload detail"
        },
        "EventSource": {
            "type": "string",
            "enum": [
                "EVENT_SOURCE_UNSPECIFIED",
                "EVENT_SOURCE_SYSTEM",
                "EVENT_SOURCE_USER"
            ],
            "default": "EVENT_SOURCE_UNSPECIFIED",
            "description": "- EVENT_SOURCE_UNSPECIFIED: Default\n - EVENT_SOURCE_SYSTEM: Event is generated as a result of status change reported by edge node / application\n - EVENT_SOURCE_USER: Event is generated as a result of an user's configuration action",
            "title": "Source of events"
        },
        "EventTopUsersData": {
            "type": "object",
            "properties": {
                "userName": {
                    "type": "string"
                },
                "eventCount": {
                    "type": "integer",
                    "format": "int64"
                }
            }
        },
        "EventTopUsersResp": {
            "type": "object",
            "properties": {
                "topUsers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/EventTopUsersData"
                    }
                }
            }
        },
        "HealthDesc": {
            "type": "object",
            "properties": {
                "hostName": {
                    "type": "string"
                },
                "envName": {
                    "type": "string"
                },
                "serviceName": {
                    "type": "string"
                },
                "serviceInstance": {
                    "type": "string"
                },
                "briefHealth": {
                    "$ref": "#/definitions/BriefHealth"
                }
            }
        },
        "HealthServiceResp": {
            "type": "object",
            "properties": {
                "healthService": {
                    "$ref": "#/definitions/HealthServiceSubType"
                },
                "hresult": {
                    "$ref": "#/definitions/ZsrvResponse"
                },
                "healthDesc": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/HealthDesc"
                    }
                }
            }
        },
        "HealthServiceSubType": {
            "type": "string",
            "enum": [
                "Publisher",
                "Subscriber"
            ],
            "default": "Publisher"
        },
        "HelloName": {
            "type": "object",
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "encryptedSecrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "cryptoKey": {
                    "type": "string"
                }
            }
        },
        "HelloResp": {
            "type": "object",
            "properties": {
                "response": {
                    "type": "string"
                }
            }
        },
        "LastKnownStatus": {
            "type": "object",
            "properties": {
                "lastKnownStatusLine": {
                    "type": "string"
                },
                "lastAttemptState": {
                    "type": "integer",
                    "format": "int32"
                },
                "lastAttemptedAt": {
                    "type": "string",
                    "format": "date-time"
                }
            }
        },
        "LocalOperatorConsoleBlob": {
            "type": "object",
            "properties": {
                "devId": {
                    "type": "string"
                },
                "config": {
                    "type": "string"
                },
                "encryptedConfig": {
                    "type": "string"
                }
            },
            "title": "Local Operator Console Blob"
        },
        "LocalOperatorConsoleBlobList": {
            "type": "object",
            "properties": {
                "localOperatorConsoleBlobList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/LocalOperatorConsoleBlob"
                    }
                },
                "controllerCerts": {
                    "type": "string"
                }
            },
            "title": "Local Operator Console Blob List"
        },
        "MetricQueryResponse": {
            "type": "object",
            "properties": {
                "threshold": {
                    "$ref": "#/definitions/MetricThreshold"
                },
                "metricType": {
                    "type": "string"
                },
                "xLabel": {
                    "type": "string"
                },
                "yLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "list": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/MetricQueryResponseItem"
                    }
                }
            }
        },
        "MetricQueryResponseItem": {
            "type": "object",
            "properties": {
                "timestamp": {
                    "type": "string",
                    "format": "date-time"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "number",
                        "format": "double"
                    }
                }
            }
        },
        "MetricThreshold": {
            "type": "object",
            "properties": {
                "yellow": {
                    "type": "number",
                    "format": "double"
                },
                "red": {
                    "type": "number",
                    "format": "double"
                }
            }
        },
        "MetricType": {
            "type": "string",
            "enum": [
                "METRIC_TYPE_UNSPECIFIED",
                "METRIC_TYPE_CPU_TOTAL",
                "METRIC_TYPE_CPU_USAGE",
                "METRIC_TYPE_MEMORY_TOTAL",
                "METRIC_TYPE_MEMORY_UTILIZATION",
                "METRIC_TYPE_NETWORK_TOTAL",
                "METRIC_TYPE_NETWORK_RATES",
                "METRIC_TYPE_EVENTS_COUNT",
                "METRIC_TYPE_STORAGE_UTILIZATION",
                "METRIC_TYPE_STORAGE_IO_ZPOOL",
                "METRIC_TYPE_STORAGE_IO_ZVOL"
            ],
            "default": "METRIC_TYPE_UNSPECIFIED",
            "title": "MetricType - On update, please update MetricType_HttpRequest as well"
        },
        "ObjectRevision": {
            "type": "object",
            "properties": {
                "prev": {
                    "type": "string",
                    "description": "Previous"
                },
                "curr": {
                    "type": "string",
                    "description": "Current Database version of the record"
                },
                "createdAt": {
                    "type": "object",
                    "format": "date-time",
                    "description": "The time, in milliseconds since the epoch, when the record was created."
                },
                "createdBy": {
                    "type": "string",
                    "description": "User data: Created By"
                },
                "updatedAt": {
                    "type": "object",
                    "format": "date-time",
                    "description": "The time, in milliseconds since the epoch, when the record was last updated."
                },
                "updatedBy": {
                    "type": "string",
                    "description": "User data: Updated By"
                }
            },
            "description": "ObjectRevision store the user details, who has doent the necessary operation like Create Operation or update operation",
            "title": "ObjectRevision is used to store the user information.",
            "required": [
                "curr",
                "createdAt",
                "createdBy",
                "updatedAt",
                "updatedBy"
            ]
        },
        "ObjectType": {
            "type": "string",
            "enum": [
                "OBJECT_TYPE_UNSPECIFIED",
                "OBJECT_TYPE_USER",
                "OBJECT_TYPE_EDGE_NODE",
                "OBJECT_TYPE_EDGE_APP",
                "OBJECT_TYPE_IMAGE",
                "OBJECT_TYPE_EDGE_APP_INSTANCE",
                "OBJECT_TYPE_PROJECT",
                "OBJECT_TYPE_NETWORK",
                "OBJECT_TYPE_DATASTORE",
                "OBJECT_TYPE_SERVICE",
                "OBJECT_TYPE_SERVICE_INSTANCE",
                "OBJECT_TYPE_ENTERPRISE",
                "OBJECT_TYPE_ROLE",
                "OBJECT_TYPE_CREDENTIAL",
                "OBJECT_TYPE_NETWORK_INSTANCE",
                "OBJECT_TYPE_VOLUME_INSTANCE",
                "OBJECT_TYPE_REALM",
                "OBJECT_TYPE_AUTHPROFILE",
                "OBJECT_TYPE_POLICY",
                "OBJECT_TYPE_APP_POLICY",
                "OBJECT_TYPE_CLUSTER_INSTANCE",
                "OBJECT_TYPE_PLUGIN",
                "OBJECT_TYPE_DOC_POLICY",
                "OBJECT_TYPE_ORCHESTRATOR_CLUSTER",
                "OBJECT_TYPE_TAGS",
                "OBJECT_TYPE_EDGE_NODE_INTERFACE",
                "OBJECT_TYPE_DEPLOYMENT",
                "OBJECT_TYPE_ENTITLEMENTS",
                "OBJECT_TYPE_DATA_STREAM",
                "OBJECT_TYPE_API_USAGE",
                "OBJECT_TYPE_APP_INSTANCE_SNAPSHOT",
                "OBJECT_TYPE_PATCH_ENVELOPE",
                "OBJECT_TYPE_RESOURCE_USAGE_TRACK",
                "OBJECT_TYPE_PATCH_ENVELOPE_REFERENCE",
                "OBJECT_TYPE_DEV_PASSTHROUGH",
                "OBJECT_TYPE_EDGE_NODE_CLUSTER",
                "OBJECT_TYPE_ASSET_GROUP",
                "OBJECT_TYPE_APP_PROFILE",
                "OBJECT_TYPE_PROFILE_DEPLOYMENT",
                "OBJECT_TYPE_ZKS_INSTANCE",
                "OBJECT_TYPE_CLUSTER_GROUP"
            ],
            "default": "OBJECT_TYPE_UNSPECIFIED"
        },
        "PingMsgSendResp": {
            "type": "object",
            "properties": {
                "pingId": {
                    "type": "string",
                    "format": "int64"
                }
            }
        },
        "PolicyDocVersion": {
            "type": "object",
            "properties": {
                "policy": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                },
                "fileURL": {
                    "type": "string"
                },
                "revision": {
                    "$ref": "#/definitions/ObjectRevision"
                }
            }
        },
        "PolicyDocVersionList": {
            "type": "object",
            "properties": {
                "summary": {
                    "$ref": "#/definitions/Summary"
                },
                "list": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/PolicyDocVersion"
                    }
                },
                "next": {
                    "$ref": "#/definitions/Cursor"
                }
            }
        },
        "PolicyDocVersionResp": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/ZsrvResponse"
                },
                "pinfo": {
                    "$ref": "#/definitions/PolicyDocVersion"
                },
                "plist": {
                    "$ref": "#/definitions/PolicyDocVersionList"
                }
            }
        },
        "Summary": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Summary description"
                },
                "total": {
                    "type": "number",
                    "format": "int64",
                    "description": "Total"
                },
                "values": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "description": "Values: Map for storing <string, uint32>"
                }
            },
            "description": "Summary is used to store the Summary details",
            "title": "Summary is used to store the Summary details"
        },
        "WifiConfigcryptoblock": {
            "type": "object",
            "properties": {
                "identity": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "ZcOpsStatus": {
            "type": "string",
            "enum": [
                "OPS_STATUS_UNSPECIFIED",
                "OPS_STATUS_PENDING",
                "OPS_STATUS_ONGOING",
                "OPS_STATUS_COMPLETE"
            ],
            "default": "OPS_STATUS_UNSPECIFIED",
            "description": "- OPS_STATUS_PENDING: In rare cases, system may not start operation when it was requested. Client will be notified that operation is PENDING\n - OPS_STATUS_ONGOING: system will start the operation, but at the time response was generated, operation is still ONGOING.\n - OPS_STATUS_COMPLETE: Even if the result of the operations may result in failure, but the OpsStatus will marked COMPLETE for almost all cases.",
            "title": "ZedCloud internal operation status"
        },
        "ZcOpsType": {
            "type": "string",
            "enum": [
                "OPS_TYPE_UNSPECIFIED",
                "OPS_TYPE_READ",
                "OPS_TYPE_DELETE",
                "OPS_TYPE_CREATE",
                "OPS_TYPE_UPDATE",
                "OPS_TYPE_LIST"
            ],
            "default": "OPS_TYPE_UNSPECIFIED",
            "title": "ZedCloud internal operation type"
        },
        "ZsrvError": {
            "type": "object",
            "properties": {
                "ec": {
                    "$ref": "#/definitions/ZsrvErrorCode",
                    "title": "Enumrated error code, describes more granular numerical\nvalue than just httpStatus"
                },
                "location": {
                    "type": "string",
                    "title": "Ignore: Internal field only"
                },
                "details": {
                    "type": "string",
                    "title": "Field captures string description of details"
                }
            }
        },
        "ZsrvErrorCode": {
            "type": "string",
            "enum": [
                "zMsgErrorNone",
                "zMsgSucess",
                "NotFound",
                "AlreadyExists",
                "VersionMismatch",
                "RangeError",
                "LargeResult",
                "IncompleteData",
                "InvalidData",
                "FunctionUnsupported",
                "NoMemory",
                "SendFailure",
                "Timeout",
                "BadReqBody",
                "BadReqParam",
                "InvalidFieldFormat",
                "UrlNotFound",
                "ApiVersionNotSupported",
                "Unauthorized",
                "Forbidden",
                "Conflict",
                "NotModified",
                "DependencyConflict",
                "JsonFmtError",
                "ProtoFmtError",
                "CertError",
                "DataBaseConnection",
                "DBError",
                "zMsgAccepted",
                "zMsgCreated",
                "PreConditionFailed",
                "InternalServerError"
            ],
            "default": "zMsgErrorNone",
            "description": "- zMsgErrorNone: common validation errors\n - IncompleteData: message had fields that weren't filled in\n - InvalidData: message contained the field that wasn't expected\n - FunctionUnsupported: this feature unavailable on this version of device\n - InvalidFieldFormat: message contained the field that wasn't correctly formatted\n - JsonFmtError: Marshal / Unmarshal errors\n - DataBaseConnection: generic DB error",
            "title": "ZedCould internal error code"
        },
        "ZsrvResponse": {
            "type": "object",
            "properties": {
                "operationType": {
                    "$ref": "#/definitions/ZcOpsType",
                    "title": "Describes one of the operations type : possible values\n                        Read/Delete/Create/Update/List"
                },
                "operationStatus": {
                    "$ref": "#/definitions/ZcOpsStatus",
                    "title": "if this is log running job"
                },
                "objectKind": {
                    "type": "string",
                    "title": "zedcloud object kind on which the operation was performed"
                },
                "objectId": {
                    "type": "string",
                    "title": "Unique value identifies the object that was operated on"
                },
                "objectName": {
                    "type": "string",
                    "title": "name of the object"
                },
                "objectRevision": {
                    "type": "string",
                    "title": "object revision post the operation, note Read operation\ndoesn't change the revision"
                },
                "objectType": {
                    "$ref": "#/definitions/ObjectType"
                },
                "operationTime": {
                    "type": "string",
                    "title": "time of operation"
                },
                "startTime": {
                    "type": "string",
                    "title": "total time taken by operations"
                },
                "endTime": {
                    "type": "string"
                },
                "user": {
                    "type": "string",
                    "title": "the operation is performed on behalf of this user"
                },
                "httpStatusCode": {
                    "type": "integer",
                    "format": "int32",
                    "title": "http response"
                },
                "httpStatusMsg": {
                    "type": "string",
                    "title": "summary of the error in text format"
                },
                "jobId": {
                    "type": "string",
                    "title": "for tracking asynchronous tasks"
                },
                "error": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/ZsrvError"
                    },
                    "title": "one or more errors will be set if the operation failed\ni.e. httpStatusCode != 2xx"
                }
            }
        },
        "commonCellularIPType": {
            "type": "string",
            "enum": [
                "CELLULAR_IP_TYPE_UNSPECIFIED",
                "CELLULAR_IP_TYPE_IPV4",
                "CELLULAR_IP_TYPE_IPV4_AND_IPV6",
                "CELLULAR_IP_TYPE_IPV6"
            ],
            "default": "CELLULAR_IP_TYPE_UNSPECIFIED",
            "description": "The IP addressing type to use for a given attach or default bearer.\n\n - CELLULAR_IP_TYPE_UNSPECIFIED: IP type is not specified.\nWhen unspecified, EVE will not enforce an IP type in the bearer configuration.\nThe modem will instead use its built-in profiles (see CellularProfile) to determine\nthe appropriate IP type for the network.\n - CELLULAR_IP_TYPE_IPV4: IPv4 only.\n - CELLULAR_IP_TYPE_IPV4_AND_IPV6: IPv4 and IPv6.\n - CELLULAR_IP_TYPE_IPV6: IPv6 only."
        },
        "commonCipherBlock": {
            "type": "object",
            "properties": {
                "cipherContextId": {
                    "type": "string",
                    "title": "cipher context id"
                },
                "initialValue": {
                    "type": "string",
                    "format": "byte",
                    "title": "Initial Value for Symmetric Key derivation"
                },
                "cipherData": {
                    "type": "string",
                    "format": "byte",
                    "title": "encrypted sensitive data"
                },
                "clearTextSha256": {
                    "type": "string",
                    "format": "byte",
                    "title": "sha256 of the plaintext sensitive data"
                }
            },
            "title": "Encrypted sensitive data information"
        },
        "commonCipherContext": {
            "type": "object",
            "properties": {
                "contextId": {
                    "type": "string",
                    "title": "cipher context id, key to this structure"
                },
                "hashScheme": {
                    "$ref": "#/definitions/commonHashAlgorithm",
                    "title": "algorithm used to compute hash for certificates"
                },
                "keyExchangeScheme": {
                    "$ref": "#/definitions/commonKeyExchangeScheme",
                    "description": "for key exchange scheme, like ECDH etc."
                },
                "encryptionScheme": {
                    "$ref": "#/definitions/commonEncryptionScheme",
                    "description": "for encrypting sensitive data, like AES256 etc."
                },
                "deviceCertHash": {
                    "type": "string",
                    "format": "byte",
                    "title": "device public certificate hash"
                },
                "controllerCertHash": {
                    "type": "string",
                    "format": "byte",
                    "title": "controller certificate hash"
                }
            },
            "title": "Cipher information to decrypt Sensitive Data"
        },
        "commonConnectivityProbe": {
            "type": "object",
            "properties": {
                "probeMethod": {
                    "$ref": "#/definitions/commonConnectivityProbeMethod",
                    "description": "Method to use to determine the connectivity status."
                },
                "probeEndpoint": {
                    "$ref": "#/definitions/commonProbeEndpoint",
                    "description": "Endpoint to probe using the selected probing mechanism to determine\nthe connectivity status."
                }
            },
            "description": "Configuration for user-defined connectivity-testing probe."
        },
        "commonConnectivityProbeMethod": {
            "type": "string",
            "enum": [
                "CONNECTIVITY_PROBE_METHOD_UNSPECIFIED",
                "CONNECTIVITY_PROBE_METHOD_ICMP",
                "CONNECTIVITY_PROBE_METHOD_TCP"
            ],
            "default": "CONNECTIVITY_PROBE_METHOD_UNSPECIFIED",
            "description": "User-defined method to use to determine the connectivity status.\n\n - CONNECTIVITY_PROBE_METHOD_UNSPECIFIED: Connectivity probing method is not specified and therefore will not be used.\n - CONNECTIVITY_PROBE_METHOD_ICMP: Use ICMP ping against the probed endpoint to determine the connectivity status.\n - CONNECTIVITY_PROBE_METHOD_TCP: Try to establish TCP connection with the probed endpoint to determine the connectivity\nstatus."
        },
        "commonDHCPType": {
            "type": "string",
            "enum": [
                "DHCPNoop",
                "Static",
                "DHCPNone",
                "Client"
            ],
            "default": "DHCPNoop",
            "title": "- Static: Statically configure the DHCP for port\n - DHCPNone: Don't run any DHCP, we are in passthrough mode for app\n - Client: Run the DHCP client on this port"
        },
        "commonDhcpOptionsIgnore": {
            "type": "object",
            "properties": {
                "ntpServerExclusively": {
                    "type": "boolean",
                    "description": "When true, statically configured NTP servers are used exclusively,\nignoring any NTP servers provided by DHCP.\nIf true and no static NTP servers are set, no NTP servers will be used.\nFor DHCP (IPv4), this applies to option 42.\nFor DHCPv6 (IPv6), this applies to option 56."
                },
                "ipAddressesExclusively": {
                    "type": "boolean",
                    "description": "When true, statically configured IP addresses are used exclusively,\nignoring any IP addresses provided by DHCP.\nIf true and no static IP addresses are set, the interface will have no IP assigned."
                },
                "dnsConfigExclusively": {
                    "type": "boolean",
                    "description": "When true, statically configured DNS servers and domain name(s) are used\nexclusively, ignoring any DNS-related configuration provided by DHCP.\nIf true and no static DNS servers are set, no DNS servers will be used.\nSimilarly, if no static domain name(s) are set, no domain name(s) will be used.\nFor DHCP (IPv4), this applies to option 6 (DNS servers), option 15\n(single domain name), and option 119 (search domains).\nFor DHCPv6 (IPv6), this applies to option 23 (DNS servers) and option 24\n(domain search list)."
                },
                "gatewaysExclusively": {
                    "type": "boolean",
                    "description": "When true, statically configured gateway addresses are used exclusively,\nignoring any routers provided by DHCP.\nIf true and no static routers are set, no gateway will be used.\nFor DHCP (IPv4), this applies to option 3.\nFor DHCPv6 (IPv6), this applies to option 24."
                }
            },
            "description": "DhcpOptionsIgnore specifies which DHCP-provided options\nshould be ignored by the device, allowing static configuration\nto override DHCP where applicable.\n\nCurrently supported options include:\n  - IP addresses\n  - NTP servers\n  - DNS servers and domains\n  - Router (gateway) addresses\n\nThis allows flexible merging or exclusive use of static config fields.\n\nFor full DHCP option references:\n  - DHCP: https://www.iana.org/assignments/bootp-dhcp-parameters/bootp-dhcp-parameters.xhtml\n  - DHCPv6: https://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml"
        },
        "commonEncryptionScheme": {
            "type": "string",
            "enum": [
                "SA_NONE",
                "SA_AES_256_CFB"
            ],
            "default": "SA_NONE",
            "title": "Encryption Scheme for Cipher Payload"
        },
        "commonHashAlgorithm": {
            "type": "string",
            "enum": [
                "HASH_ALGORITHM_INVALID",
                "HASH_ALGORITHM_SHA256_16BYTES",
                "HASH_ALGORITHM_SHA256_32BYTES"
            ],
            "default": "HASH_ALGORITHM_INVALID"
        },
        "commonKeyExchangeScheme": {
            "type": "string",
            "enum": [
                "KEA_NONE",
                "KEA_ECDH"
            ],
            "default": "KEA_NONE",
            "title": "Security Key Exchange Method"
        },
        "commonNetworkType": {
            "type": "string",
            "enum": [
                "NETWORKTYPENOOP",
                "V4",
                "V6",
                "CryptoV4",
                "CryptoV6",
                "CryptoEID",
                "V4Only",
                "V6Only",
                "DualV4V6"
            ],
            "default": "NETWORKTYPENOOP"
        },
        "commonPhyIoMemberUsage": {
            "type": "string",
            "enum": [
                "PhyIoUsageNone",
                "PhyIoUsageMgmtAndApps",
                "PhyIoUsageShared",
                "PhyIoUsageDedicated",
                "PhyIoUsageDisabled",
                "PhyIoUsageMgmtOnly"
            ],
            "default": "PhyIoUsageNone",
            "description": "PhyIoMemberUsage - Indicates how each adaptor must be used by Eve.\n\n - PhyIoUsageMgmtAndApps: Used by both management and apps.\n - PhyIoUsageShared: Shared by multiple apps\n - PhyIoUsageDedicated: used by only one app\n - PhyIoUsageDisabled: Adapter Blocked. Do not use the Adapter.\n - PhyIoUsageMgmtOnly: Used for Management traffic only. Cannot be used by Apps."
        },
        "commonPhyIoType": {
            "type": "string",
            "enum": [
                "PhyIoNoop",
                "PhyIoNetEth",
                "PhyIoUSB",
                "PhyIoCOM",
                "PhyIoAudio",
                "PhyIoNetWLAN",
                "PhyIoNetWWAN",
                "PhyIoHDMI",
                "PhyIoNVMEStorage",
                "PhyIoSATAStorage",
                "PhyIoNetEthPF",
                "PhyIoNetEthVF",
                "PhyIoUSBController",
                "PhyIoUSBDevice",
                "PhyIoCAN",
                "PhyIoVCAN",
                "PhyIoLCAN",
                "PhyIoOther"
            ],
            "default": "PhyIoNoop"
        },
        "commonProbeEndpoint": {
            "type": "object",
            "properties": {
                "host": {
                    "type": "string",
                    "description": "IP address or FQDN."
                },
                "port": {
                    "type": "integer",
                    "format": "int64",
                    "description": "TCP port required for CONNECTIVITY_PROBE_METHOD_TCP.\nLeave empty for CONNECTIVITY_PROBE_METHOD_ICMP."
                }
            },
            "description": "Address of a remote endpoint to probe in order to determine connectivity status."
        },
        "commonProxyConfig": {
            "type": "object",
            "properties": {
                "networkProxyEnable": {
                    "type": "boolean",
                    "title": "enable network level proxy in the form of WPAD"
                },
                "proxies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/commonProxyServer"
                    },
                    "title": "dedicated per protocol information"
                },
                "exceptions": {
                    "type": "string",
                    "title": "exceptions separated by commas"
                },
                "pacfile": {
                    "type": "string",
                    "title": "or pacfile can be in place of others\nbase64 encoded"
                },
                "networkProxyURL": {
                    "type": "string",
                    "title": "Direct URL for wpad.dat download"
                },
                "proxyCertPEM": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "byte"
                    },
                    "title": "Uploaded proxy certificate or certificate chain for MITM\nthis may be needed either in explicit (has ProxyServer items), automatic\n(networkProxyEnable) or transparent (network layer not aware of proxy)"
                }
            }
        },
        "commonProxyServer": {
            "type": "object",
            "properties": {
                "proto": {
                    "$ref": "#/definitions/commonproxyProto"
                },
                "server": {
                    "type": "string"
                },
                "port": {
                    "type": "integer",
                    "format": "int64"
                }
            }
        },
        "commonWiFiKeyScheme": {
            "type": "string",
            "enum": [
                "SchemeNOOP",
                "WPAPSK",
                "WPAEAP"
            ],
            "default": "SchemeNOOP"
        },
        "commonZnetStaticDNSEntry": {
            "type": "object",
            "properties": {
                "HostName": {
                    "type": "string"
                },
                "Address": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "title": "These are list of static mapping that can be added to network"
        },
        "commonipRange": {
            "type": "object",
            "properties": {
                "start": {
                    "type": "string"
                },
                "end": {
                    "type": "string"
                }
            }
        },
        "commonipspec": {
            "type": "object",
            "properties": {
                "dhcp": {
                    "$ref": "#/definitions/commonDHCPType"
                },
                "subnet": {
                    "type": "string",
                    "title": "subnet is CIDR format...x.y.z.l/nn"
                },
                "gateway": {
                    "type": "string"
                },
                "domain": {
                    "type": "string"
                },
                "ntp": {
                    "type": "string",
                    "title": "ntp and more_ntp are used as a union to specify several NTP servers\nvia IP address or FQDN\nthis is for historical reasons when we only allowed to specify one\nNTP server"
                },
                "moreNtp": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "dns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "dhcpRange": {
                    "$ref": "#/definitions/commonipRange",
                    "description": "for IPAM management when dhcp is turned on.\nIf none provided, system will default pool."
                },
                "dhcpOptionsIgnore": {
                    "$ref": "#/definitions/commonDhcpOptionsIgnore",
                    "title": "Even if DhcpType is Client, EVE still accepts static\nIP config and will merge it with the DHCP-provided one by default\nuse the following option to override this behavior"
                }
            },
            "title": "Common for IPv4 and IPv6"
        },
        "commonproxyProto": {
            "type": "string",
            "enum": [
                "PROXY_HTTP",
                "PROXY_HTTPS",
                "PROXY_SOCKS",
                "PROXY_FTP",
                "PROXY_OTHER"
            ],
            "default": "PROXY_HTTP"
        },
        "configACE": {
            "type": "object",
            "properties": {
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configACEMatch"
                    },
                    "title": "multiple matches here is for various fields of 6 tuples\n for example\n    1) host=www.example.com & port=http\n    2) ip=8.8.8.8 & port=53 & proto=UDP\n    3) adapter=uplink && port=8080 && proto=TCP"
                },
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configACEAction"
                    },
                    "description": "Expect only single action...repeated here is\nfor future work."
                },
                "name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "format": "int32"
                },
                "dir": {
                    "$ref": "#/definitions/configACEDirection"
                }
            }
        },
        "configACEAction": {
            "type": "object",
            "properties": {
                "drop": {
                    "type": "boolean"
                },
                "limit": {
                    "type": "boolean",
                    "title": "limit action, and its associated parameter"
                },
                "limitrate": {
                    "type": "integer",
                    "format": "int64"
                },
                "limitunit": {
                    "type": "string"
                },
                "limitburst": {
                    "type": "integer",
                    "format": "int64"
                },
                "portmap": {
                    "type": "boolean",
                    "title": "port map action, and its associated parameter"
                },
                "appPort": {
                    "type": "integer",
                    "format": "int64"
                }
            }
        },
        "configACEDirection": {
            "type": "string",
            "enum": [
                "BOTH",
                "INGRESS",
                "EGRESS"
            ],
            "default": "BOTH"
        },
        "configACEMatch": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string",
                    "description": "Supported ACE match types:\n  * \"ip\": value should be an IP address of a remote endpoint. The match is satisfied\n          for outbound and inbound flow if the destination and the source IP address\n          matches the given value, respectively. Can be combined with any other match\n          type to further narrow down the selection criteria.\n  * \"host\": value should be a domain name of a remote endpoint. It can be either a fully\n            qualified, or a partially qualified domain name (FQDN or PQDN). A packet is\n            matched if it is destined to or originated from an IP address that was obtained\n            by a DNS query for that exact domain or any of its subdomains. For example,\n            match of type \"host\" with value \"domain.com\" will also apply to the endpoint\n            \"subdomain.domain.com\". Can be combined with other match types except for \"eidset\".\n  * \"eidset\": special match type for the overlay network. Matches IPs of all applications\n              deployed in the same network as well as all IPs with statically configured\n              DNS entries (under the config field NetworkInstanceConfig.Dns). For this type,\n              value field is not used. Can be combined with other match types except for\n              \"host\".\n  * \"protocol\": value should specify the protocol to match. Protocol can be one of \"tcp\",\n                \"udp\", \"icmp\", or \"all\", or it can be a numeric value, representing one\n                of these protocols or a different one. A protocol name from /etc/protocols\n                is also allowed. Protocol match can be combined with any other match type\n                (often combined with port numbers).\n  * \"lport\": value should be an application local port number. For filtering actions,\n             this is the source port for outbound traffic and destination port for inbound\n             traffic. For PORTMAP action, this represents application port as exposed\n             to the external network (i.e., if <edge-node-ip>:2222 is mapped to <app-ip>:22,\n             lport refers to 2222). lport can be combined with any other match type.\n             It is actually required to combine \"lport\" and \"protocol\" inside the same ACE.\n             In other words, port without protocol is not valid.\n  * \"fport\": value should be a remote endpoint port number (foreign port). Used for filtering\n             actions, but not for PORTMAP (do not confuse with \"lport\", which is still used to\n             represent the forwarded port - the forwarded port is still considered as local).\n             \"fport\" can be combined with any other match type. It is actually required\n             to combine \"fport\" with \"protocol\" inside the same ACE. In other words, port\n             without protocol is not valid.\n * \"adapter\": value should be an adapter shared label (SystemAdapter.shared_labels).\n              It can be used for an inbound ACE to apply the rule only to packets arriving\n              via one of the matched network adapters. Typically used to activate a given\n              port-forwarding rule (PORTMAP) for only a subset of network adapters.\n              When not specified, the rule applies to every port attached to the network\n              instance (i.e. equivalent to setting \"adapter\" to the pre-defined shared\n              label \"all\").\n              Adapter label cannot be used for outbound ACE. This is because the EVE firewall\n              is applied before routing, and the output network adapter is not yet known."
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "configAdapter": {
            "type": "object",
            "properties": {
                "type": {
                    "$ref": "#/definitions/commonPhyIoType"
                },
                "name": {
                    "type": "string"
                },
                "ethVf": {
                    "$ref": "#/definitions/configEthVF"
                },
                "interfaceOrder": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Define the network interface order relative to other directly assigned\nnetwork devices and virtual network adapters.\nOnly applies to (assignable) network adapters, i.e. types: \"PhyIoNetEth\", \"PhyIoNetWLAN\",\n\"PhyIoNetWWAN\" and \"PhyIoNetEthVF\".\nThe numbering is across both the \"Adapter\" (direct assignments) and the \"NetworkAdapter\"\n(virtual interfaces) lists for a given \"AppInstanceConfig\", thus every entry in these\nlists, excluding non-networking adapters, must have a unique order number\n(when the \"enforce_network_interface_order\" is enabled, see \"VmConfig\").\nInterface with a lower order value should appear inside the application before\ninterface with a higher order value.\nThe implementation of this ordering may depend on the hypervisor. For example,\nthe hypervisor might virtualize the PCI bus and assign lower PCI addresses to\ninterfaces with lower order values. But the actual outcome of interface ordering\ndepends on the application and EVE therefore cannot guarantee desired order.\nSince this field was introduced in later versions, older EVE versions do not support\nuser-defined interface ordering. For backward compatibility, the user-defined\norder is applied only if \"enforce_network_interface_order\" is enabled for the given\napplication (see \"VmConfig\", file \"vm.proto\")."
                }
            },
            "description": "Adapter bundles corresponding to a subset of what is in ZioBundle\nWhen used by a NetworkInstanceConfig the name is the logicallabel\nfor the network adapter."
        },
        "configAddressType": {
            "type": "string",
            "enum": [
                "First",
                "IPV4",
                "IPV6",
                "CryptoIPV4",
                "CryptoIPV6",
                "Last"
            ],
            "default": "First"
        },
        "configAppDebugAccessPolicy": {
            "type": "object",
            "properties": {
                "allowApp": {
                    "type": "boolean",
                    "title": "app side of edge-view access is allowed or not"
                }
            },
            "title": "App debug policy applicable to edge-view"
        },
        "configAppInstanceConfig": {
            "type": "object",
            "properties": {
                "uuidandversion": {
                    "$ref": "#/definitions/configUUIDandVersion"
                },
                "displayname": {
                    "type": "string"
                },
                "fixedresources": {
                    "$ref": "#/definitions/configVmConfig"
                },
                "drives": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configDrive"
                    },
                    "description": "VolumeRefs, if supported by EVE, will supersede drives. Drives still\nexist for backward compatibility.\nDrives will be deprecated in the future.\nThe order here is critical because they are presented to the VM or\ncontainer in the order they are listed, e.g., the first VM image\nwill be the root disk."
                },
                "activate": {
                    "type": "boolean",
                    "description": "Set activate to start the application instance; clear it to stop it."
                },
                "interfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configNetworkAdapter"
                    },
                    "description": "NetworkAdapter are virtual adapters assigned to the application\nThe order here is critical because they are presented to the VM or\ncontainer in the order they are listed, e.g., the first NetworkAdapter\nwill appear in a Linux VM as eth0. Also, the MAC address is determined\nbased on the order in the list."
                },
                "adapters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configAdapter"
                    },
                    "title": "Physical adapters such as eth1 or USB controllers and GPUs assigned\nto the application instance.\nThe Name in Adapter should be set to PhysicalIO.assigngrp"
                },
                "restart": {
                    "$ref": "#/definitions/configInstanceOpsCmd",
                    "description": "The device behavior for a restart command (if counter increased)\nis to restart the application instance\nIncreasing this multiple times does not imply the application instance\nwill restart more than once.\nEVE can assume that the adapters did not change."
                },
                "purge": {
                    "$ref": "#/definitions/configInstanceOpsCmd",
                    "description": "The EVE behavior for a purge command is to restart the application instance\nwith the first drive/volumeRef recreated from its origin."
                },
                "userData": {
                    "type": "string",
                    "description": "App Instance initialization configuration data provided by user\nThis will be used as \"user-data\" in cloud-init\nEmpty string will indicate that cloud-init is not required\nIt is also used to carry environment variables for containers.\nXXX will be deprecated and replaced by the cipherData below."
                },
                "remoteConsole": {
                    "type": "boolean",
                    "description": "Config flag if the app-instance should be made accessible\nthrough a remote console session established by the device."
                },
                "cipherData": {
                    "$ref": "#/definitions/commonCipherBlock",
                    "title": "contains the encrypted userdata"
                },
                "collectStatsIPAddr": {
                    "type": "string",
                    "title": "The static IP address assigned on the NetworkAdapter which App Container\nstats collection uses. If the 'collectStatsIPAddr' is not empty and valid,\nit enables the container stats collection for this App.\nDuring App instance creation, after user enables the collection of stats\nfrom App, cloud needs to make sure at least one 'Local' type of Network-Instance\nis assigned to the App interface, and based on the subnet of the NI, statically\nassign an IP address on the same subnet, e.g. 10.1.0.100"
                },
                "volumeRefList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configVolumeRef"
                    },
                    "description": "The volumes to be attached to the app-instance.\nThe order here is critical because they are presented to the VM or\ncontainer in the order they are listed, e.g., the first VM image\nwill be the root disk.\nNote that since the name volumeRef was used before and deprecated\npython protobuf seems to require that we use a different name."
                },
                "metaDataType": {
                    "$ref": "#/definitions/configMetaDataType",
                    "title": "metadata type to use for app if provided inside userData"
                },
                "profileList": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "profile_list is a set of strings which can be used to control which sets\nof applications are run. Combined with the activate flag above.\nIf the profile list is empty it means wildcard; application will\nbe started independent of the global or local profile specified for the\ndevice."
                },
                "startDelayInSeconds": {
                    "type": "integer",
                    "format": "int64",
                    "description": "start_delay_in_seconds - Applicable only when EVE boots up fresh and starts\napplications for the first time after boot up. This is the amount of time that\nEVE waits (after boot finish) before starting each application.\nDefault value 0 -> start application immediately.\nNon-Zero value -> After EVE is ready to start application instance, wait for the\ngiven amount of time before starting the respective application instance."
                },
                "service": {
                    "type": "boolean",
                    "title": "service - run app instance as a service container in the host/dom0\nwill override default capabilities with configuration\ndefined in org.mobyproject.config label of image provided by linuxkit"
                },
                "cloudInitVersion": {
                    "type": "integer",
                    "format": "int64",
                    "description": "All changes to the cloud-init config are tracked using this version field -\nonce the version is changed cloud-init tool restarts in a guest."
                },
                "snapshot": {
                    "$ref": "#/definitions/configSnapshotConfig",
                    "title": "SnapshotConfig is used to track the snapshots of the app instance"
                },
                "patchRef": {
                    "$ref": "#/definitions/configPatchEnvelopeRef",
                    "title": "PatchEnvelopeRef is used to track all patch envelopes used by the app instance"
                },
                "designatedNodeId": {
                    "type": "string",
                    "title": "This edge-node UUID for the Designate Node for the Application"
                },
                "vmResolution": {
                    "type": "string",
                    "description": "Custom resolution applies to VM that is running in FML mode only."
                },
                "runtimeType": {
                    "$ref": "#/definitions/configAppRuntimeType",
                    "title": "AppRuntimeType - to indicate the types of Application Runtime Deployment"
                }
            },
            "description": "The complete configuration for an Application Instance\nWhen changing key fields such as the drives/volumeRefs or the number\nof interfaces, the controller is required to issue a purge command i.e.,\nincrease the purge counter. Otherwise there will be an error (The controller\ncan also issue a purge command to re-construct the content of the first\ndrive/volumeRef without any changes.)\nSome changes such as ACL changes in the interfaces do not require a restart,\nbut all other changes (such as fixedresources and adapters) require a\nrestart command i.e., an increase to the restart counter. The restart counter\ncan also be increased to cause an application instance restart without\nany other change to the application instance."
        },
        "configAppRuntimeType": {
            "type": "string",
            "enum": [
                "APP_RUNTIME_TYPE_UNSPECIFIED",
                "APP_RUNTIME_TYPE_DOCKER"
            ],
            "default": "APP_RUNTIME_TYPE_UNSPECIFIED",
            "description": "AppRuntimeType - to indicate the types of Application Deployment\nFor instance, the need to gather of docker container metrics and logs\nfrom the agent inside applications on EVE device."
        },
        "configArpMonitor": {
            "type": "object",
            "properties": {
                "interval": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Interval specifies the ARP link monitoring frequency in milliseconds."
                },
                "ipTargets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IpTargets specifies the IPv4 addresses to use as ARP monitoring peers.\nThese are the targets of ARP requests sent to determine the health of links."
                }
            },
            "description": "ArpMonitor : ARP-based link monitoring parameters.\nDefined for BondAdapter."
        },
        "configBaseOS": {
            "type": "object",
            "properties": {
                "contentTreeUuid": {
                    "type": "string",
                    "title": "UUID for ContentTree with BaseOS image"
                },
                "retryUpdate": {
                    "$ref": "#/definitions/configDeviceOpsCmd",
                    "description": "retry_update\nRetry the BaseOs update if the update failed previously.\n1) If this image is in FAILED state, retry the image update.\n2) If this image is already active and fully installed (PartitionState = UPDATED),\n   Do nothing. Just update the baseos_update_counter in Info message.\n3) If this image is same as active image, but status is NOT yet UPDATED, or\n   if the update to this image is in progress, wait till the update\n   concludes (Success / Error+rollback) - then trigger the retry as needed."
                },
                "activate": {
                    "type": "boolean",
                    "title": "if not set BaseOS will be installed,\nbut not activated"
                },
                "baseOsVersion": {
                    "type": "string"
                }
            }
        },
        "configBaseOSConfig": {
            "type": "object",
            "properties": {
                "uuidandversion": {
                    "$ref": "#/definitions/configUUIDandVersion"
                },
                "drives": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configDrive"
                    },
                    "description": "volumeID will supersede drives. Drives still\nexist for backward compatibility.\nDrives will be deprecated in the future."
                },
                "activate": {
                    "type": "boolean"
                },
                "baseOSVersion": {
                    "type": "string"
                },
                "volumeID": {
                    "type": "string"
                }
            }
        },
        "configBondAdapter": {
            "type": "object",
            "properties": {
                "logicallabel": {
                    "type": "string",
                    "description": "Name of this bond adapter."
                },
                "interfaceName": {
                    "type": "string",
                    "description": "A physical name of the bond interface.\nNote that the interface name is limited in Linux kernel to 15 characters.\nIf not defined, logicallabel will be used instead."
                },
                "lowerLayerNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Logical names of aggregated PhysicalIOs.\nFor all bonding modes but Active-Backup the order is irrelevant.\nIn the Active-Backup mode (BOND_MODE_ACTIVE_BACKUP), the first PhysicalIO\nin the list will be considered as the primary port (i.e. only when\nthe primary is off-line will alternate ports be used)."
                },
                "bondMode": {
                    "$ref": "#/definitions/configBondMode",
                    "title": "A bonding mode specifies the policy indicating how bonding slaves are used\nduring network transmission"
                },
                "mii": {
                    "$ref": "#/definitions/configMIIMonitor",
                    "description": "The MII monitor is driver-dependent. It monitors the links from the device\nto the nearest connected switch. If the failure occurs beyond the nearest\nconnected switch, it cannot be detected by MII monitor."
                },
                "arp": {
                    "$ref": "#/definitions/configArpMonitor",
                    "description": "The ARP monitor is based on the communication to the target\nhosts designated by their IP addresses. Even if the link is beyond\nthe nearest connected switch, the APR monitor can detect it."
                },
                "lacpRate": {
                    "$ref": "#/definitions/configLacpRate",
                    "description": "Option specifying the rate in which EVE will ask LACP link partners\nto transmit LACPDU packets in 802.3ad mode."
                }
            },
            "description": "BondAdapter aggregates multiple PhysicalIOs into one adapter for redundancy\nand load-spreading purposes."
        },
        "configBondMode": {
            "type": "string",
            "enum": [
                "BOND_MODE_UNSPECIFIED",
                "BOND_MODE_BALANCE_RR",
                "BOND_MODE_ACTIVE_BACKUP",
                "BOND_MODE_BALANCE_XOR",
                "BOND_MODE_BROADCAST",
                "BOND_MODE_802_3AD",
                "BOND_MODE_BALANCE_TLB",
                "BOND_MODE_BALANCE_ALB"
            ],
            "default": "BOND_MODE_UNSPECIFIED",
            "description": "A bonding mode specifies the policy indicating how bonding slaves are used\nduring network transmission.\n\n - BOND_MODE_UNSPECIFIED: BOND_MODE_UNSPECIFIED : if bonding mode is not explicitly specified,\nthen by default Round-Robin policy is applied (BOND_MODE_BALANCE_RR).\n - BOND_MODE_BALANCE_RR: BOND_MODE_BALANCE_RR : transmit packets in sequential order from the first\navailable slave through the last. This mode provides load balancing\nand fault tolerance.\nThis is the default bonding mode.\n - BOND_MODE_ACTIVE_BACKUP: BOND_MODE_ACTIVE_BACKUP : only one slave in the bond is active.\nA different slave becomes active if, and only if, the active slave fails.\nThe bond's MAC address is externally visible on only one port to avoid\nconfusing the switch.\nThis mode provides fault tolerance.\n - BOND_MODE_BALANCE_XOR: BOND_MODE_BALANCE_XOR : packet source and destination MAC addresses are\nused to calculate hash and select the output slave interface accordingly.\nThis algorithm will place all traffic destined to a particular network\npeer on the same slave.\nThis mode provides load balancing and fault tolerance.\n - BOND_MODE_BROADCAST: BOND_MODE_BROADCAST: transmits everything on all slave interfaces.\nThis mode provides fault tolerance.\n - BOND_MODE_802_3AD: BOND_MODE_802_3AD : IEEE 802.3ad Dynamic link aggregation.\nCreates aggregation groups that share the same speed and duplex settings.\nUtilizes all slaves in the active aggregator according to the 802.3ad\nspecification.\nRequires that upstream networks equipment supports and has the IEEE 802.3ad\nDynamic link aggregation properly configured.\n - BOND_MODE_BALANCE_TLB: BOND_MODE_BALANCE_TLB : adaptive transmit load balancing. Channel bonding that\ndoes not require any special switch support. The outgoing traffic\nis distributed according to the current load (computed relative to the speed)\non each slave.\nIncoming traffic is received by the current slave. If the receiving slave\nfails, another slave takes over the MAC address of the failed receiving slave.\nThis mode provides (TX) load balancing and fault tolerance.\n - BOND_MODE_BALANCE_ALB: BOND_MODE_BALANCE_ALB : adaptive load balancing. Includes BOND_MODE_BALANCE_TLB\nplus receive load balancing (RLB) for IPV4 traffic, and does not require\nany special switch support. The receive load balancing is achieved by ARP\nnegotiation.\nThis mode provides load balancing and fault tolerance."
        },
        "configCellularAccessPoint": {
            "type": "object",
            "properties": {
                "simSlot": {
                    "type": "integer",
                    "format": "int64",
                    "description": "SIM card slot to which this configuration applies.\n0 - unspecified (apply to currently activated or the only available)\n1 - config for SIM card in the first slot\n2 - config for SIM card in the second slot\netc."
                },
                "apn": {
                    "type": "string",
                    "description": "Access Point Network to connect into.\nBy default it is \"internet\".\nApplies to the default bearer.\nTo modify the attach bearer APN, use attach_apn instead."
                },
                "authProtocol": {
                    "$ref": "#/definitions/evecommonCellularAuthProtocol",
                    "description": "Authentication protocol used by the network.\nApplies to the default bearer.\nTo modify the authentication protocol for the attach bearer, use attach_auth_protocol instead."
                },
                "cipherData": {
                    "$ref": "#/definitions/commonCipherBlock",
                    "description": "Cipher data may contain encrypted user credentials\n(inside cellular_net_* fields of EncryptionBlock).\nEncryptionBlock allows separate configuration of credentials for the attach\nand default bearers."
                },
                "preferredPlmns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of cellular network operators that modem should preferably try to register\nand connect into.\nNetwork operator should be referenced by PLMN (Public Land Mobile Network) code,\nconsisting of 3-digits MCC (Mobile Country Code) and 2 or 3-digits MNC (Mobile Network Code),\nseparated by a dash, e.g. \"310-260\".\nIf empty, then modem will select the network automatically based on the SIM card config."
                },
                "forbidRoaming": {
                    "type": "boolean",
                    "description": "If true, then modem will avoid connecting to networks with roaming."
                },
                "preferredRats": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/evecommonRadioAccessTechnology"
                    },
                    "description": "The list of preferred Radio Access Technologies (RATs) to use for connecting\nto the network.\nOrder matters, first is the most preferred, second is tried next, etc.\nNot listed technologies will not be tried.\nIf empty, then modem will select RAT automatically."
                },
                "ipType": {
                    "$ref": "#/definitions/commonCellularIPType",
                    "description": "The IP addressing type to use for the default bearer."
                },
                "attachApn": {
                    "type": "string",
                    "description": "Access Point Name (APN) for the attach (initial) bearer.\nThis field is optional. If not specified, EVE will not send any attach bearer\nconfiguration to the modem. Instead, the modem will use one of its pre-installed\nprofiles (see CellularProfile) to determine the configuration."
                },
                "attachIpType": {
                    "$ref": "#/definitions/commonCellularIPType",
                    "description": "The IP addressing type to use for the attach bearer.\nLeave undefined if attach_apn is not specified."
                },
                "attachAuthProtocol": {
                    "$ref": "#/definitions/evecommonCellularAuthProtocol",
                    "description": "Authentication protocol used for the attach bearer.\nLeave undefined if attach_apn is not specified."
                }
            },
            "description": "CellularAccessPoint contains config parameters for connecting to a cellular network."
        },
        "configCellularConfig": {
            "type": "object",
            "properties": {
                "APN": {
                    "type": "string",
                    "description": "APN string - by default it is \"internet\".\nTO BE DEPRECATED: Fill connection arguments inside access_points instead.\nIf access_points is non-empty, then APN field is ignored."
                },
                "probe": {
                    "$ref": "#/definitions/configCellularConnectivityProbe",
                    "description": "Optional cellular connectivity probing.\nBy default it is enabled."
                },
                "locationTracking": {
                    "type": "boolean",
                    "description": "Some LTE modems have GNSS receiver integrated and can be used for device\nlocation tracking.\nEnable this option to have location info periodically obtained from this\nmodem and published to controller and to applications."
                },
                "accessPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configCellularAccessPoint"
                    },
                    "description": "Parameters to apply for connecting to cellular networks.\nConfigured separately for every SIM card inserted into the modem."
                },
                "activatedSimSlot": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Select SIM card slot to activate.\nCurrently, EVE support only single-standby SIM card mode.\n0 - unspecified (leave the currently activated)\n1 - activate the first SIM slot\n2 - activate the second SIM slot\netc."
                }
            }
        },
        "configCellularConnectivityProbe": {
            "type": "object",
            "properties": {
                "disable": {
                    "type": "boolean",
                    "description": "If true, then probing is disabled."
                },
                "probeAddress": {
                    "type": "string",
                    "description": "IP/FQDN to periodically probe using 3 pings per iteration to determine connectivity status.\nThis field is now deprecated and replaced with custom_probe (see below).\nTo maintain backward-compatibility, EVE will check both probe_address and custom_probe\nand will use whichever has non-zero value (if any), but preferring custom_probe."
                },
                "customProbe": {
                    "$ref": "#/definitions/commonConnectivityProbe",
                    "description": "User-defined probe for cellular connectivity testing.\nOnly IP address is allowed as ConnectivityProbe.probe_address (and port if needed),\nnot hostname.\nThe probing algorithm is more complex that just testing reachability of a remote\nendpoint and the goal is to minimize generated traffic, probing time and false negatives\n(that would trigger undesired re-connect).\nEVE will periodically check the modem status, accessibility of DNS server(s) and potentially\nalso proxies in the local network, and only as the last resort (if connectivity state\nis still unclear) it will probe the remote endpoint. If custom_probe is not defined,\nEVE will try to ping \"8.8.8.8\" (Google public DNS).\nIt is recommended to use custom probe for private LTE networks where public DNS servers\nmight not be allowed by the firewall (and hence ping would fail even with a working\nconnectivity)."
                }
            },
            "description": "CellularConnectivityProbe is used to periodically check the connectivity status of a cellular network\nby probing a remote endpoint.\nWhenever the probe fails, the cellular connection is automatically restarted. If the probe keeps failing\neven after the restart, the failure is reported in ZCellularStatus.probeError.\nThe connectivity probing interval is 5 minutes and currently it is not configurable."
        },
        "configConfigItem": {
            "type": "object",
            "properties": {
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "description": "Timers and other per-device policy which relates to the interaction\nwith zedcloud. Note that the timers are randomized on the device\nto avoid synchronization with other devices. Random range is between\nbetween .5 and 1.5 of these nominal values. If not set (i.e. zero),\nit means the default value of 60 seconds."
        },
        "configContentTree": {
            "type": "object",
            "properties": {
                "uuid": {
                    "type": "string"
                },
                "dsId": {
                    "type": "string"
                },
                "URL": {
                    "type": "string"
                },
                "iformat": {
                    "$ref": "#/definitions/configFormat"
                },
                "sha256": {
                    "type": "string",
                    "title": "The sha is for the top blob of the ContentTree"
                },
                "maxSizeBytes": {
                    "type": "string",
                    "format": "uint64",
                    "description": "maxSizeBytes used for capping resource consumption in EVE.\nmaxSizeBytes indicates the maximum download size of content tree."
                },
                "siginfo": {
                    "$ref": "#/definitions/configSignatureInfo"
                },
                "displayName": {
                    "type": "string"
                },
                "generationCount": {
                    "type": "string",
                    "format": "int64",
                    "description": "For container ContentTree, sha256 might not be available in config.\nIf the sha256 is not available then it needs to be resolved corresponding to the tag\nchange in generation_count indicates that the resolution of tag is needed\ngeneration_count needs to be updated when purge is required for an existing\ninstance. In case of new instance using the same content tree, EVE will get\nnew content tree UUID in the device configuration from the controller."
                },
                "customMetaData": {
                    "type": "string",
                    "description": "An arbitrary string. Usage depends on the content purpose. Currently the\nonly usage is with custom application blobs (AppCustom) - this string will\nappear in the restAPI endpoint available at http://169.254.169.254. So user\napplication can read that data and treat the blob accordingly."
                },
                "dsIdsList": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DatastoreConfig UUIDs, that must have the same content. In case of\nnetwork failure, the download process can fallback to the next datastore\nin the list."
                },
                "designatedNodeId": {
                    "type": "string",
                    "description": "To inform the edge-node if the device receiving this content tree is\nresponsible for content tree download or not."
                }
            },
            "title": "ContentTree describes the top of some content tree. The controller needs\nto allocate a uuid for it, and that uuid will be sent by EVE in the\nZInfoContentTree message"
        },
        "configDatastoreConfig": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "dType": {
                    "$ref": "#/definitions/configDsType"
                },
                "fqdn": {
                    "type": "string"
                },
                "apiKey": {
                    "type": "string",
                    "title": "to be deprecated, use cipherData instead"
                },
                "password": {
                    "type": "string",
                    "title": "to be deprecated, use cipherData instead"
                },
                "dpath": {
                    "type": "string",
                    "title": "depending on datastore types, it could be bucket or path"
                },
                "region": {
                    "type": "string",
                    "title": "Applies for some datastore types"
                },
                "cipherData": {
                    "$ref": "#/definitions/commonCipherBlock",
                    "title": "contains the encrypted credentials"
                },
                "dsCertPEM": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "byte"
                    },
                    "title": "Uploaded datastore certificate or certificate chain"
                }
            },
            "title": "The DataStoreConfig contains common parameters for a give source of\nimages aka ContentTrees, such as the credentials and server"
        },
        "configDevDebugAccessPolicy": {
            "type": "object",
            "properties": {
                "allowDev": {
                    "type": "boolean",
                    "title": "device side of edge-view access is allowed or not"
                }
            },
            "title": "Dev debug policy applicable to edge-view"
        },
        "configDeviceOpsCmd": {
            "type": "object",
            "properties": {
                "counter": {
                    "type": "integer",
                    "format": "int64"
                },
                "desiredState": {
                    "type": "boolean"
                },
                "opsTime": {
                    "type": "string",
                    "title": "FIXME: change to timestamp, once we move to gogo proto"
                }
            },
            "description": "Device Operational Commands Semantic\nFor rebooting device,  command=Reset, counter = counter+delta, desiredState = on\nFor poweroff device,  command=Reset, counter = counter+delta, desiredState = off\nFor backup at midnight, command=Backup, counter = counter+delta, desiredState=n/a, opsTime = mm/dd/yy:hh:ss\nCurrent implementation does support only single command outstanding for each\ntype. In future can be extended to have more scheduled events."
        },
        "configDiskConfig": {
            "type": "object",
            "properties": {
                "disk": {
                    "$ref": "#/definitions/evecommonDiskDescription"
                },
                "oldDisk": {
                    "$ref": "#/definitions/evecommonDiskDescription",
                    "title": "define old disk here to replace it with new one defined in disk, omit it to not use replacement"
                },
                "diskConfig": {
                    "$ref": "#/definitions/configDiskConfigType"
                }
            },
            "title": "DiskConfig describe desired configuration of disk\nIf we want change state to online/offline we should define its state\nIf we want to add disk we should define it here and set DiskConfigType to online or offline\nIf we want to remove disk we should set its state to unused or appdirect\nIf we want to replace disk we should fill old_disk to be replaced with disk\nProgress of operation is expected to be available in info messages"
        },
        "configDiskConfigType": {
            "type": "string",
            "enum": [
                "DISK_CONFIG_TYPE_UNSPECIFIED",
                "DISK_CONFIG_TYPE_EVEOS",
                "DISK_CONFIG_TYPE_PERSIST",
                "DISK_CONFIG_TYPE_ZFS_ONLINE",
                "DISK_CONFIG_TYPE_ZFS_OFFLINE",
                "DISK_CONFIG_TYPE_APPDIRECT",
                "DISK_CONFIG_TYPE_UNUSED"
            ],
            "default": "DISK_CONFIG_TYPE_UNSPECIFIED",
            "title": "DiskConfigType is the desired configuration of disks"
        },
        "configDisksArrayType": {
            "type": "string",
            "enum": [
                "DISKS_ARRAY_TYPE_UNSPECIFIED",
                "DISKS_ARRAY_TYPE_RAID0",
                "DISKS_ARRAY_TYPE_RAID1",
                "DISKS_ARRAY_TYPE_RAID5",
                "DISKS_ARRAY_TYPE_RAID6"
            ],
            "default": "DISKS_ARRAY_TYPE_UNSPECIFIED",
            "title": "DisksArrayType is the desired configuration of disks in DisksConfig"
        },
        "configDisksConfig": {
            "type": "object",
            "properties": {
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configDiskConfig"
                    }
                },
                "arrayType": {
                    "$ref": "#/definitions/configDisksArrayType"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configDisksConfig"
                    }
                }
            },
            "description": "For example to use stripe of two pairs of mirrored disks we should define\nDisksConfig without disks with array_type DISKS_ARRAY_TYPE_RAID0\nwith two children with properly defined disks inside and with array_type DISKS_ARRAY_TYPE_RAID1\nand empty children",
            "title": "DisksConfig is a configuration of disks\nWe expect information about disks to be filled and will try to adjust disks states accordingly\nAll disks defined in disks field expected to have array type defined in array_type\nTo support nested topologies we can use children field"
        },
        "configDrive": {
            "type": "object",
            "properties": {
                "image": {
                    "$ref": "#/definitions/eveconfigImage"
                },
                "readonly": {
                    "type": "boolean"
                },
                "preserve": {
                    "type": "boolean"
                },
                "drvtype": {
                    "$ref": "#/definitions/configDriveType"
                },
                "target": {
                    "$ref": "#/definitions/configTarget"
                },
                "maxsizebytes": {
                    "type": "string",
                    "format": "int64",
                    "description": "maxsizebytes indicates the maximum size of the volume.\nInitial image size will be resized to the maxsizebytes\niff maxsizebytes is greater than the image size."
                }
            },
            "title": "XXX the Drive will be deprecated and we will use Volumes instead"
        },
        "configDriveType": {
            "type": "string",
            "enum": [
                "Unclassified",
                "CDROM",
                "HDD",
                "NET",
                "HDD_EMPTY"
            ],
            "default": "Unclassified",
            "description": "- HDD_EMPTY: this type is allocate the empty disk of maxsizebytes specified",
            "title": "XXX the DriveType will be deprecated when we deprecate Drive"
        },
        "configDsType": {
            "type": "string",
            "enum": [
                "DsUnknown",
                "DsHttp",
                "DsHttps",
                "DsS3",
                "DsSFTP",
                "DsContainerRegistry",
                "DsAzureBlob",
                "DsGoogleStorage"
            ],
            "default": "DsUnknown"
        },
        "configEVE_OPAQUE_OBJECT_CATEGORY": {
            "type": "string",
            "enum": [
                "UNKOWN",
                "BASE64",
                "BINARYBLOB",
                "SECRET"
            ],
            "default": "UNKOWN"
        },
        "configEVE_PATCH_ENVELOPE_ACTION": {
            "type": "string",
            "enum": [
                "STORE",
                "ACTIVATE"
            ],
            "default": "STORE"
        },
        "configEdgeDevConfig": {
            "type": "object",
            "properties": {
                "id": {
                    "$ref": "#/definitions/configUUIDandVersion"
                },
                "apps": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configAppInstanceConfig"
                    }
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configNetworkConfig"
                    }
                },
                "datastores": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configDatastoreConfig"
                    }
                },
                "base": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configBaseOSConfig"
                    },
                    "description": "OBSOLETE - base. Use baseos instead. Controller should fill this for\nbackward compatibility till all the Older Eve images are no longer\nsupported."
                },
                "reboot": {
                    "$ref": "#/definitions/configDeviceOpsCmd"
                },
                "backup": {
                    "$ref": "#/definitions/configDeviceOpsCmd"
                },
                "configItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configConfigItem"
                    }
                },
                "systemAdapterList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configSystemAdapter"
                    },
                    "description": "systemAdapterList - List of DeviceNetworkAdapters. Only Network\n adapters ( Ex: eth0, wlan1 etc ) have a corresponding SystemAdapter.\nnon-Network adapters do not have systemadapters."
                },
                "deviceIoList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configPhysicalIO"
                    },
                    "title": "deviceIoList - List of Physical Adapters. Includes both Network\n Adapters and Non-Network Adapters ( USB / Com etc )"
                },
                "manufacturer": {
                    "type": "string",
                    "title": "Override dmidecode info if set"
                },
                "productName": {
                    "type": "string"
                },
                "networkInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configNetworkInstanceConfig"
                    }
                },
                "cipherContexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/commonCipherContext"
                    },
                    "title": "controller supplies a list of cipher contexts,\ncontaining certificate and other details, to be\nused for sensitive data decryption"
                },
                "contentInfo": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configContentTree"
                    },
                    "description": "These images aka ContentTrees and Volumes should be created by EVE\nindependently of any application usage.\nApplication instances will refer to the volumes."
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configVolume"
                    }
                },
                "controllercertConfighash": {
                    "type": "string",
                    "description": "This field is used by the device to detect when it needs to re-download\nthe controller certs using the /certs API endpoint.\nThe controller just needs to ensure this value changes when it wants the\ndevice to re-fetch the controller certs, for instance by having it\nbe a hash of all of the controller certificates."
                },
                "maintenanceMode": {
                    "type": "boolean",
                    "description": "deprecated 23;\nIf maintence_mode is set the device will operate in a limited mode e.g.,\nnot start applications etc as to enable inspection of its state and\nrecover from bad state."
                },
                "controllerEpoch": {
                    "type": "string",
                    "format": "int64",
                    "title": "controller_epoch indicates current epoch of config\nif we set new epoch, EVE sends all info messages to controller\nit captures when a new controller takes over and needs all the info be resent"
                },
                "baseos": {
                    "$ref": "#/definitions/configBaseOS",
                    "title": "Baseos Config Block"
                },
                "globalProfile": {
                    "type": "string",
                    "description": "global_profile, if set, controls set of applications which will run.\nThe Activate=true app instances which have this profile in their profile_list\nwill run. If the global_profile is not set, then the profile_list is not\nused to gate the application instances."
                },
                "localProfileServer": {
                    "type": "string",
                    "title": "local_profile_server, if set, indicates a hostname/IPv4/IPv6 address and\noptional port number at which EVE will request for a local profile.\nIf such a local profile is retrieved, it will override the global_profile.\nThe syntax follows the usual URL server name syntax thus the following\nare example valid strings:\n   [fe80::1]:1234\n   10.1.1.1:1234\n   hostname:1234\n   [fe80::1]\n   10.1.1.1\n   hostname\nIf the port number is not specified, it will default to 8888"
                },
                "profileServerToken": {
                    "type": "string",
                    "description": "Together with a local_profile_server one can specify a\nprofile_server_token. EVE must verify that the response from the\nlocal_profile_server contains this token."
                },
                "vlans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configVlanAdapter"
                    },
                    "description": "A list of VLAN sub-interfaces configured for EVE management traffic and\nfor local network instances."
                },
                "bonds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configBondAdapter"
                    },
                    "description": "A list of bond interfaces (LAGs) aggregating physical network adapters."
                },
                "edgeview": {
                    "$ref": "#/definitions/configEdgeViewConfig",
                    "title": "edge-view configuration"
                },
                "disks": {
                    "$ref": "#/definitions/configDisksConfig",
                    "title": "disks configuration"
                },
                "shutdown": {
                    "$ref": "#/definitions/configDeviceOpsCmd",
                    "description": "Graceful shutdown of all app instances on the edge node.\nAny local profile server is shut down after all the other app instances\nhave halted.\nNote that this does not power off the edge node since there is no remote\npower on capability; power off can be done locally using the Local Profile\nServer API."
                },
                "deviceName": {
                    "type": "string"
                },
                "projectName": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string"
                },
                "enterpriseName": {
                    "type": "string"
                },
                "enterpriseId": {
                    "type": "string"
                },
                "configTimestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp updated by controller whenever device config is modified.\nUsed by EVE to properly order configurations that originate at the same controller\nbut get submitted to device through different ways:\n    /config API vs. initial config for bootstrapping vs. USB-based config override etc.\nThis ensures that device will not accidentally revert back to an older configuration.\nDoes not apply to legacy override.json and usb.json mechanisms."
                },
                "locConfig": {
                    "$ref": "#/definitions/configLOCConfig",
                    "title": "Configuration of the Local Operator Console (LOC)"
                },
                "patchEnvelopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configEvePatchEnvelope"
                    }
                },
                "cluster": {
                    "$ref": "#/definitions/eveconfigEdgeNodeCluster",
                    "title": "cluster configuration"
                }
            },
            "description": "This is the response to a GET /api/v1/edgeDevice/config\nThe EdgeDevConfig message carries all of the device's configuration from\nthe controller to the device.\nThe device will request these messages either periodically or as a result\nof some TBD notification.\nThe message is assumed to be protected by a TLS session bound to the\ndevice certificate."
        },
        "configEdgeViewConfig": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string",
                    "title": "JWT token for signed info, it contains the dispatcher\nendpoint IP:Port, device UUID, nonce and expiration time"
                },
                "dispCertPem": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "byte"
                    },
                    "title": "dispatcher certificate(s) if it's not well-known CA signed"
                },
                "devPolicy": {
                    "$ref": "#/definitions/configDevDebugAccessPolicy",
                    "title": "policy for device access through edge-view"
                },
                "appPolicy": {
                    "$ref": "#/definitions/configAppDebugAccessPolicy",
                    "title": "policy access for apps through edge-view"
                },
                "extPolicy": {
                    "$ref": "#/definitions/configExternalEndPointPolicy",
                    "title": "policy access for external endpoint through edge-view"
                },
                "generationId": {
                    "type": "integer",
                    "format": "int64",
                    "title": "Generation ID for re-start edgeview without parameter changes"
                }
            }
        },
        "configEncryptedExternalOpaqueBinaryBlob": {
            "type": "object",
            "properties": {
                "cipherData": {
                    "$ref": "#/definitions/commonCipherBlock",
                    "title": "Encrypted serialized copy of ExternalOpaqueBinaryBlob"
                }
            }
        },
        "configEncryptedInlineOpaqueBase64Data": {
            "type": "object",
            "properties": {
                "cipherData": {
                    "$ref": "#/definitions/commonCipherBlock",
                    "title": "Encrypted serialized copy of InlineOpaqueBase64Data"
                }
            }
        },
        "configEthVF": {
            "type": "object",
            "properties": {
                "index": {
                    "type": "integer",
                    "format": "int64"
                },
                "mac": {
                    "type": "string"
                },
                "vlanId": {
                    "type": "integer",
                    "format": "int64"
                }
            },
            "title": "Information regarding Virtual Function (VF) customisation"
        },
        "configEveBinaryArtifact": {
            "type": "object",
            "properties": {
                "format": {
                    "$ref": "#/definitions/configEVE_OPAQUE_OBJECT_CATEGORY",
                    "title": "base64 or binary blob only - secret type is invalid"
                },
                "inline": {
                    "$ref": "#/definitions/eveconfigInlineOpaqueBase64Data"
                },
                "volumeRef": {
                    "$ref": "#/definitions/eveconfigExternalOpaqueBinaryBlob"
                },
                "encryptedInline": {
                    "$ref": "#/definitions/configEncryptedInlineOpaqueBase64Data",
                    "description": "There is an intended skip in field IDs here\nto handle the existing artifactMetaData\nand metadata_cipher_data fields."
                },
                "encryptedVolumeref": {
                    "$ref": "#/definitions/configEncryptedExternalOpaqueBinaryBlob"
                },
                "artifactMetaData": {
                    "type": "string",
                    "title": "If metadata_cipher_data is set then artifactMetaData can be ignored"
                },
                "metadataCipherData": {
                    "$ref": "#/definitions/commonCipherBlock",
                    "description": "Optional encryption for EveBinaryArtifact.artifactMetaData\nCipherBlock.cipherData should contain the encrypted serialized\ncopy of an EncryptionBlock structure with\nEncryptionBlock.user = ENCRYPTION_BLOCK_USER_BINARY_ARTIFACT_METADATA\nand EncryptionBlock.encrypted_data set to the EveBinaryArtifact.artifactMetaData text."
                }
            }
        },
        "configEvePatchEnvelope": {
            "type": "object",
            "properties": {
                "displayName": {
                    "type": "string",
                    "title": "Unique name provided by user"
                },
                "uuid": {
                    "type": "string",
                    "title": "Unique"
                },
                "version": {
                    "type": "string",
                    "title": "arbitrary version from user"
                },
                "action": {
                    "$ref": "#/definitions/configEVE_PATCH_ENVELOPE_ACTION",
                    "title": "way this object should be treated"
                },
                "artifacts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configEveBinaryArtifact"
                    }
                },
                "appInstIdsAllowed": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "title": "List of application instance ids that should\nbe allowed to access this patch envelope"
                },
                "createTime": {
                    "type": "string",
                    "format": "date-time",
                    "title": "Time object created in UTC format"
                }
            }
        },
        "configExternalEndPointPolicy": {
            "type": "object",
            "properties": {
                "allowExt": {
                    "type": "boolean",
                    "title": "external of device side of edge-view access is allowed or not"
                }
            },
            "title": "External Endpoint applicable to edge-view\nTo mean the entity external to the device, e.g. a local-profile server on the LAN outside of mgmt\nor app-shared ports. since it's not part of EVE, and not part of EVE applications. In the EdgeView code,\nif tcp session setup is to an address we don't have, it identifies the request as 'external'"
        },
        "configFormat": {
            "type": "string",
            "enum": [
                "FmtUnknown",
                "RAW",
                "QCOW",
                "QCOW2",
                "VHD",
                "VMDK",
                "OVA",
                "VHDX",
                "CONTAINER",
                "ISO",
                "PVC"
            ],
            "default": "FmtUnknown"
        },
        "configInstanceOpsCmd": {
            "type": "object",
            "properties": {
                "counter": {
                    "type": "integer",
                    "format": "int64"
                },
                "opsTime": {
                    "type": "string"
                }
            }
        },
        "configLOCConfig": {
            "type": "object",
            "properties": {
                "locUrl": {
                    "type": "string",
                    "title": "If set indicates URL of the Local Operator Console (LOC)"
                },
                "datastoreCollectInfoId": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "several datastores can be specified, but at the current moment only one will be supported\nthis is done to be extensible to allow to specify the datastore or have alternatives in\ncase of failure",
                    "title": "UUID of the datastore to upload the collect-info tarball to - only DsHttp and DsHttps is currently possible\nthe directory is specified by dpath in DatastoreConfig and the filename is the standard collect-info.sh\nfilename with the device uuid concatenated,\nf.e.: eve-info-v34-2025-05-13-08-53-52-5d0767ee-0547-4569-b530-387e526f8cb9.tar.gz"
                }
            }
        },
        "configLacpRate": {
            "type": "string",
            "enum": [
                "LACP_RATE_UNSPECIFIED",
                "LACP_RATE_SLOW",
                "LACP_RATE_FAST"
            ],
            "default": "LACP_RATE_UNSPECIFIED",
            "description": "Option specifying the rate in which EVE will ask LACP link partners\nto transmit LACPDU packets in 802.3ad mode.\n\n - LACP_RATE_UNSPECIFIED: Default LACP rate is Slow.\n - LACP_RATE_SLOW: Request LACP partner to transmit LACPDUs every 30 seconds.\n - LACP_RATE_FAST: Request LACP partner to transmit LACPDUs every 1 second."
        },
        "configMIIMonitor": {
            "type": "object",
            "properties": {
                "interval": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Specifies the MII link monitoring frequency in milliseconds.\nThis determines how often the link state of each bond slave is inspected\nfor link failures."
                },
                "updelay": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Updelay specifies the time, in milliseconds, to wait before enabling\na bond slave after a link recovery has been detected.\nThe updelay value should be a multiple of the monitoring interval; if not,\nit will be rounded down to the nearest multiple.\nThe default value is 0."
                },
                "downdelay": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Specifies the time, in milliseconds, to wait before disabling a bond\nslave after a link failure has been detected.\nThe downdelay value should be a multiple of the monitoring interval; if not,\nit will be rounded down to the nearest multiple.\nThe default value is 0."
                }
            },
            "description": "MIIMonitor : MII link monitoring parameters.\nDefined for BondAdapter."
        },
        "configMetaDataType": {
            "type": "string",
            "enum": [
                "MetaDataDrive",
                "MetaDataNone",
                "MetaDataOpenStack",
                "MetaDataDriveMultipart"
            ],
            "default": "MetaDataDrive",
            "title": "Type of cloud-init data to provide to application"
        },
        "configNetworkAdapter": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                },
                "networkId": {
                    "type": "string"
                },
                "addr": {
                    "type": "string"
                },
                "hostname": {
                    "type": "string"
                },
                "cryptoEid": {
                    "type": "string",
                    "title": "more configuration for getting addr/EID"
                },
                "lispsignature": {
                    "type": "string"
                },
                "pemcert": {
                    "type": "string",
                    "format": "byte"
                },
                "pemprivatekey": {
                    "type": "string",
                    "format": "byte"
                },
                "macAddress": {
                    "type": "string",
                    "title": "Used in case of P2V, where we want to specify a macAddress\nto vif, that is simulated towards app"
                },
                "acls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configACE"
                    },
                    "title": "firewall"
                },
                "accessVlanId": {
                    "type": "integer",
                    "format": "int64",
                    "title": "access port vlan id\napp interface with access vlan id of zero will be treated as trunk port\nvalid vlan id range: 2 - 4093\nvlan id 1 is implicitly used by linux bridges"
                },
                "allowToDiscover": {
                    "type": "boolean",
                    "title": "allow AppInstance to discover other AppInstances\nattached to this network instance. Default is false"
                },
                "interfaceOrder": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Define the network interface order relative to other virtual network adapters\nand directly assigned network devices.\nThe numbering is across both the \"Adapter\" (direct assignments) and the \"NetworkAdapter\"\n(virtual interfaces) lists for a given \"AppInstanceConfig\", thus every entry in these\nlists, excluding non-networking adapters, must have a unique order number\n(when the \"enforce_network_interface_order\" is enabled, see \"VmConfig\").\nInterface with a lower order value should appear inside the application before\ninterface with a higher order value.\nThe implementation of this ordering may depend on the hypervisor. For example,\nthe hypervisor might virtualize the PCI bus and assign lower PCI addresses to\ninterfaces with lower order values. But the actual outcome of interface ordering\ndepends on the application and EVE therefore cannot guarantee desired order.\nSince this field was introduced in later versions, older EVE versions do not support\nuser-defined interface ordering. For backward compatibility, the user-defined\norder is applied only if \"enforce_network_interface_order\" is enabled for the given\napplication (see \"VmConfig\", file \"vm.proto\")."
                }
            }
        },
        "configNetworkConfig": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/commonNetworkType"
                },
                "ip": {
                    "$ref": "#/definitions/commonipspec",
                    "title": "network ip specification"
                },
                "dns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/commonZnetStaticDNSEntry"
                    }
                },
                "entProxy": {
                    "$ref": "#/definitions/commonProxyConfig",
                    "title": "enterprise proxy"
                },
                "wireless": {
                    "$ref": "#/definitions/configWirelessConfig",
                    "title": "wireless specification"
                },
                "mtu": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum transmission unit (MTU) to set on the associated network adapter(s).\nThis is the largest IP packet that the underlying link can and is allowed to carry.\nThis does not include the L2 header size (e.g. Ethernet header or a VLAN tag size).\nThe value is a 16-byte unsigned integer, representing the MTU size in bytes.\nThe minimum accepted value for the MTU is 1280 (RFC 8200, \"IPv6 minimum link MTU\").\nIf not defined (zero value), EVE will set the default MTU size, which depends\non the network adapter type. Ethernet and WiFi adapters default to 1500 bytes,\nwhile cellular modems typically receive their MTU value from the network provider\n(which EVE will use unless user overrides the MTU value)."
                }
            }
        },
        "configNetworkInstanceConfig": {
            "type": "object",
            "properties": {
                "uuidandversion": {
                    "$ref": "#/definitions/configUUIDandVersion"
                },
                "displayname": {
                    "type": "string"
                },
                "instType": {
                    "$ref": "#/definitions/configZNetworkInstType",
                    "title": "instType - Type of network instance ( local, bridge etc )"
                },
                "activate": {
                    "type": "boolean",
                    "description": "activate\n - True by default. If set to false ( deactivate), the network instance\n   configuration is downloaded to the device, but the network instance\n   itself is not created on the device."
                },
                "port": {
                    "$ref": "#/definitions/configAdapter",
                    "description": "Port(s) providing external connectivity for the network instance.\nEither a single port referenced by its name (SystemAdapter.Name, aka logical label)\nor an adapter shared-label matching zero or more network ports (ports containing this\nlabel in SystemAdapter.shared_labels).\nNote that apart from the user-defined adapter labels, EVE automatically assigns shared\nlabel \"all\" to every port, \"uplink\" to every management port and \"freeuplink\" to every\nmanagement port with zero cost.\nBoth physical (e.g. eth0) and logical (e.g. vlan0) ports are allowed.\nHowever, EVE may filter out some of the matched ports which are not compatible\nwith the network instance type (e.g. wireless adapters cannot be used with switch NI\nand ports without IP addresses are not usable for local NIs).\nNetwork instance with no assigned port (empty port reference or label not matching\nany port) is air-gapped, i.e. completely isolated from external networks.\nWith multiple ports assigned, the behaviour depends on the network instance type.\nSwitch network instance will run Rapid Spanning Tree Protocol (RSTP) to avoid bridge\nloops and the broadcast storm that results from them.\nLocal network instance will apply IP routes configured for the matched ports (either\nstatically or via DHCP) to select the next hop and the output port for a given flow.\nTraffic not matching any connected, statically-configured, or DHCP-received route,\nwill be routed according to the default route. Unless user configures a static default\nroute with customized output port selection, EVE will pick one of the ports for\nthe default route by periodic connectivity probing, performed for every selected port\n(skipped if NI has 1 or 0 ports).\nFirst, NI ports are filtered down to those with a known gateway IP. Then probing\nis used to determine connectivity status. For NIs with EVE-provided \"uplink\" or\n\"freeuplink\" labels, i.e. matching only mgmt ports, EVE checks port gateway IP\nreachability using ICMP ping and controller reachability with TCP connect to\n<controller-IP>:443. For NIs with user-defined shared-labels, possibly also matching\napp-shared ports, only ICMP ping of the port gateway is performed. EVE then picks port\nwith a working connectivity, preferring the currently used one.\nAdd a static default route (see 'static_routes\" below) to customize the output port\nselection algorithm."
                },
                "stp": {
                    "$ref": "#/definitions/configSpanningTreeProtocol",
                    "description": "Configuration for the Spanning Tree Protocol (STP), which is run for switch network\ninstance when the port label matches multiple network ports."
                },
                "cfg": {
                    "$ref": "#/definitions/configNetworkInstanceOpaqueConfig",
                    "title": "cfg - Used to pass some feature-specific configuration to the\n      network instance. For Ex: Lisp, StriongSwan etc"
                },
                "ipType": {
                    "$ref": "#/definitions/configAddressType",
                    "title": "type of ipSpec"
                },
                "ip": {
                    "$ref": "#/definitions/commonipspec",
                    "description": "network ip specification\nNote that ip.gateway must be a valid IP address and can not be all-zeroes.\nTo suppress automatic propagation of the default route into apps, configure network\ninstance as air-gapped (without port) or mark all NI ports as app-shared\n(not for management) and ensure that they will not get a default route\n(e.g. set ip.gateway of the attached NetworkConfig(s) to all-zeroes IP)."
                },
                "dns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/commonZnetStaticDNSEntry"
                    },
                    "title": "static DNS entry, if we are running DNS/DHCP service"
                },
                "propagateConnectedRoutes": {
                    "type": "boolean",
                    "description": "Enable to use DHCP to automatically propagate routes for port subnets\ninto applications connected to them indirectly through local network instances.\nThis option is only valid for local network instances. For other types\nof network instances, it will be ignored."
                },
                "staticRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/eveconfigIPRoute"
                    },
                    "description": "List of IP routes statically added to the network instance routing table.\nStatically routed subnets are also propagated to connected applications\nusing DHCP, with gateway set to the network instance bridge IP if it is\noutside of the network instance subnet.\n\nIP route gateway may point to an external endpoint (provided that network\ninstance is not air-gapped), or to an IP address of one of the applications\nconnected to the network instance. For an external gateway, user may specify\noutput port label instead of the IP address. EVE will automatically determine\nthe gateway IP address (based on the port config statically configured or received\nvia DHCP).\n\nStatic routes are handled independently from connected routes. While connected\nroutes are propagated to applications only if enabled by propagate_connected_routes,\nstatic routes are always propagated. Both connected and statically configured\nroutes can be propagated at the same time, there are no restrictions for using both.\n\nNote that the default route (with the bridge IP as the gateway) is automatically\npropagated to connected applications, unless network instance is air-gapped\n(without port) or all NI ports are app-shared (not management) and neither\nof them has a default route. In both cases, it is possible to enforce default\nroute propagation by configuring a static default route for the network instance.\n\nFor more info on static and connected routes please refer to:\nhttps://wiki.lfedge.org/display/EVE/Connected+and+Static+IP+Route\n\nThis option is only valid for local network instances. For other types\nof network instances, it will be ignored."
                },
                "mtu": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum transmission unit (MTU) to set for the network instance and all application\ninterfaces connected to it.\nThis is the largest IP packet that the network instance is allowed to carry.\nThis does not include the L2 header size (e.g. Ethernet header or a VLAN tag size).\nThe value is a 16-byte unsigned integer, representing the MTU size in bytes.\nThe minimum accepted value for the MTU is 1280 (RFC 8200, \"IPv6 minimum link MTU\").\nIf not defined (zero value), EVE will set the MTU to the default value of 1500 bytes.\nOn the host side, MTU is set to interfaces by EVE. On the guest (app) side,\nthe responsibility to set the MTU lies either with EVE or with the user/app, depending on\nthe network instance, app type and the type of interfaces used (local or switch,\nVM or container, virtio or emulated).\nFor container applications running inside an EVE-created shim-VM, EVE initializes\nthe MTU of interfaces during shim-VM boot. Furthermore, interfaces connected\nto local network instances will have their MTUs automatically updated if there is\na change in MTU configuration. To update the MTU of interfaces connected to switch\nnetwork instances, the user may run an external DHCP server in the network and publish\nMTU changes via DHCP option 26 (the DHCP client run by EVE inside shim-VM will pick it up\nand apply it).\nIn the case of VM applications, it is mostly the responsibility of the app/user to set\nand keep the MTUs up-to-date.\nIf device provides HW-assisted virtualization capabilities, EVE will connect VM with\nnetwork instances using para-virtualized virtio interfaces, which allow to propagate MTU\nvalue from the host to the guest. If the virtio driver used by the app supports the MTU\npropagation (VIRTIO_NET_F_MTU feature flag is set), the initial MTU values will be set\nusing virtio (regardless of the network instance type).\nTo support MTU update for interfaces connected to local network instances, the app can\nrun a DHCP client and receive the latest MTU via DHCP option 26. For switch network\ninstances, the user can run his own external DHCP server in the network with the MTU\noption configured.\nPlease note that application traffic leaving or entering the device via a network\nadapter associated with the network instance is additionally limited by MTU values\nof NI ports, configured within their NetworkConfig objects (refer to netconfig.proto).\nIf the configured network instance MTU is higher than MTU of any of the NI ports,\nEVE will flag the network instance with an error and use the lowest MTU among\nall the NI ports for the network instance instead. This is to prevent apps from sending\npackets exceeding the path MTU. Packets entering NI via port with a higher MTU and with\nsize exceeding the NI MTU will get fragmented inside EVE (if allowed by IP header).\nBy default (if MTU is not configured by the user, i.e. 'mtu' is zero), EVE uses 1500\nas MTU for air-gapped network instances and the lowest MTU among NI ports for NIs with\nexternal connectivity."
                },
                "disableFlowlog": {
                    "type": "boolean",
                    "description": "Disable flow logging for this network instance.\nWhen flow logging is enabled, EVE periodically records all application TCP and UDP\nflows. A flow record includes the application UUID, VIF name, open/close timestamps,\nsource/destination IP/port/protocol 5-tuple, and packet and byte counters.\nAdditionally, EVE records every DNS request made by an application, including\nthe request time, the hostname being resolved, and the returned IP address(es).\nThe flow logging API can be found in proto/config/flowlog/flowlog.proto\nIf flow logging is not needed, it is recommended to disable this feature as it\ncan potentially generate a large amount of data, which is then uploaded to the controller.\nDepending on the implementation, it may also introduce additional packet processing\noverhead."
                },
                "vlanAccessPorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configVlanAccessPort"
                    },
                    "description": "VLAN access ports configured for a switch network instance.\nFor other types of network instances, this option is ignored.\nThis setting applies to physical network ports attached to the network instance.\nVLAN configuration for application interfaces is applied separately via AppInstanceConfig\n(see NetworkAdapter.access_vlan_id)."
                },
                "forwardLldp": {
                    "type": "boolean",
                    "description": "Enables forwarding of LLDP (Link Layer Discovery Protocol) frames across this\nnetwork instance.\nLLDP is used by devices to advertise identity and capabilities to directly\nconnected neighbors, and is often required for topology discovery and network\nmanagement tools.\nWhen enabled, LLDP frames (EtherType 0x88cc) are not dropped or suppressed\nby the forwarding plane."
                }
            }
        },
        "configNetworkInstanceLispConfig": {
            "type": "object",
            "properties": {
                "LispMSs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configZcServicePoint"
                    }
                },
                "LispInstanceId": {
                    "type": "integer",
                    "format": "int64"
                },
                "allocate": {
                    "type": "boolean"
                },
                "exportprivate": {
                    "type": "boolean"
                },
                "allocationprefix": {
                    "type": "string",
                    "format": "byte"
                },
                "allocationprefixlen": {
                    "type": "integer",
                    "format": "int64"
                },
                "experimental": {
                    "type": "boolean",
                    "title": "various configuration to dataPlane, lispers.net vs Zededa"
                }
            },
            "title": "Lisp NetworkInstance config"
        },
        "configNetworkInstanceOpaqueConfig": {
            "type": "object",
            "properties": {
                "oconfig": {
                    "type": "string"
                },
                "lispConfig": {
                    "$ref": "#/definitions/configNetworkInstanceLispConfig"
                },
                "type": {
                    "$ref": "#/definitions/configZNetworkOpaqueConfigType"
                }
            },
            "description": "Network Instance Opaque config. In future we might add more fields here\nbut idea is here. This is service specific configuration."
        },
        "configPatchEnvelopeRef": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "title": "one of them should be non-empty\nnon-empty name overrides the id"
                },
                "id": {
                    "type": "string"
                }
            }
        },
        "configPhyIOUsagePolicy": {
            "type": "object",
            "properties": {
                "freeUplink": {
                    "type": "boolean"
                }
            },
            "title": "Given additional details for EVE software to how to treat this\ninterface. Example policies could be limit use of LTE interface\nor only use Eth1 only if Eth0 is not available etc\nNote that this is the static information from the model.\nCurrent configuration is in systemAdapter"
        },
        "configPhysicalIO": {
            "type": "object",
            "properties": {
                "ptype": {
                    "$ref": "#/definitions/commonPhyIoType"
                },
                "phylabel": {
                    "type": "string",
                    "title": "physical label typically printed on box.\nExample Eth0, Eth1, Wifi0, ComA, ComB"
                },
                "phyaddrs": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The hardware bus address. The key to this map can be of the following\n(case-insensitive) values:\n\"pcilong\": the address is a PCI id of the form 0000:02:00.0\n\"ifname\": the address is a string for a network interface like \"eth1\"\n\"serial\": the address is a Linux serial port alias such as \"/dev/ttyS2\"\n\"irq\": the address is a number such as \"5\". This can be a comma\n   separated list of integers or even a range of integers. Hence using\n   a string to address this.\n\"ioports\": the address is a string such as \"2f8-2ff\"\n\"usbaddr\": the address is a USB of the form of \"1:2.3\"\nIf the type is PhyIoNet*, then there needs to be an \"ifname\" physaddr."
                },
                "logicallabel": {
                    "type": "string",
                    "title": "logicallabel - provides the ability to model designer to refer\n   the physicalIO port to using more friendly name\nFor example Eth0->Mgmt0\n or USBA->ConfigDiskA etc"
                },
                "assigngrp": {
                    "type": "string",
                    "description": "This is the name used in AppInstanceConfig.adapters to assign an\nadapter to an application.\n\nIf assigngrp is not set, the Adapter cannot be assigned to any\napplication. One example is, when the adapter is on the same Pci\nbus as another device required by Dom0.\n\nEven if there is only one device on the its PCIBus, the assignGrp Must\nbe set.",
                    "title": "assigngrp\nAssignment Group, is unique label that is applied across PhysicalIOs\nEntireGroup can be assigned to application or nothing at all"
                },
                "usage": {
                    "$ref": "#/definitions/commonPhyIoMemberUsage",
                    "title": "usage - indicates the role of adapter ( mgmt / blocked / app-direct\n   etc. )"
                },
                "usagePolicy": {
                    "$ref": "#/definitions/configPhyIOUsagePolicy",
                    "description": "usagePolicy - Policy Object used to further refine the usage.\nFor example, specify if this should be only used as fallback?\n   Or used as the primary uplink? Allow App traffic? restrict\n   app traffic?? etc.."
                },
                "cbattr": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "title": "physical and logical attributes\n   For example in WWAN to which firmware version to load etc"
                },
                "vflist": {
                    "$ref": "#/definitions/configVfList",
                    "title": "list of Virtual Functions (VF) for given Physical Function (PF)\nonly applies for PHY_IO_TYPE_PHY_IO_NET_ETH_PF"
                },
                "parentassigngrp": {
                    "type": "string",
                    "description": "Parent Assignment Group is there to reference the parent assignment\ngroup in order to make the device dependent on a different device.\nCurrently the concrete reason to do this is to make a usb device dependent\non the PCI address the USB controller is using to prevent passthrough of\nthe USB controller in one application while trying to passthrough\na USB device on this controller to another application.\n\nWe only allow these two cases:\n- children and their parent devices are assigned to the same application\n  instance\n- parent device stays in host and one or more children (in separate\n  assignment groups) are assigned to one or more application instances",
                    "title": "parentassigngrp"
                }
            },
            "title": "PhysicalIO:\n   Absolute low level description of physical buses and ports that are\n   available on given platform.\n   Collection of these IOs, constitute what we would call as hardware\n   model. Each physical IO is manageable and visible to EVE software, and\n   it can be further configured to either provide IP connectivity or\n   directly be given to workloads"
        },
        "configPortProbe": {
            "type": "object",
            "properties": {
                "enableGwPing": {
                    "type": "boolean",
                    "description": "Use ICMP ping towards the port's gateway IP to determine connectivity status.\nThis probing is performed much more frequently than the custom_probe and provides\nfaster fail-over. On the other hand, it generates more traffic through the probed\nports. Use gw_ping_max_cost (see below) to limit which ports it is enabled for\nbased on the port cost.\nAvoid using this probe method if the gateway router is configured to drop/ignore\nICMP pings and therefore this probe method would return false negatives."
                },
                "gwPingMaxCost": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Ports exceeding this cost will have the gateway probing disabled to reduce\ntraffic generated by probing (only less-frequent custom_probe will be performed)."
                },
                "customProbe": {
                    "$ref": "#/definitions/commonConnectivityProbe",
                    "description": "User-defined method to use to determine the port connectivity status.\nRun additionally to gateway pings (if enabled)."
                }
            },
            "description": "Configuration for port connectivity probe."
        },
        "configSignatureInfo": {
            "type": "object",
            "properties": {
                "intercertsurl": {
                    "type": "string"
                },
                "signercerturl": {
                    "type": "string"
                },
                "signature": {
                    "type": "string",
                    "format": "byte"
                }
            },
            "description": "XXX this will be deprecated when all deployed instances of EVE\nno longer expect it. 5.6.X depend on it. 5.7.1 does not."
        },
        "configSnapshotConfig": {
            "type": "object",
            "properties": {
                "activeSnapshot": {
                    "type": "string",
                    "description": "active_snapshot is the id of the snapshot which is expected to be used by\nthe application.\nIt may be empty if no snapshot expected to be used."
                },
                "rollbackCmd": {
                    "$ref": "#/definitions/configInstanceOpsCmd",
                    "description": "rollback_cmd is used to trigger a rollback to the snapshot with the\nactive_snapshot id.\nThe counter inside the InstanceOpsCmd is incremented when a snapshot is\nused for a rollback. It should not be decreased.\nThe counter's semantics is the same as the one used in the restart/purge\ncommands. It's necessary for the cases, when the state of the device is\nbehind the controller because it hasn't yet managed to fetch the latest\ndeclarative statement. Only increasing the counter will trigger the\nrollback."
                },
                "maxSnapshots": {
                    "type": "integer",
                    "format": "int64",
                    "description": "max_snapshots is the maximum number of snapshots that can be stored for the\napplication instance.\nIf the number of snapshots exceeds the max_snapshots, the oldest snapshot\nwill be deleted. It's so even if the oldest snapshot is the active one.\nAs an example, let's consider the following scenario:\nThe value of max_snapshots is 1. Then a snapshot is created. VM continues\nworking. Then a rollback to the snapshot created earlier is requested, so\nthe first snapshot becomes active. EVE performs the rollback. Then the\ncontroller requests a new snapshot be created. EVE is configured to store\nonly 1 snapshot, hence the first one should be deleted."
                },
                "snapshots": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configSnapshotDesc"
                    },
                    "description": "snapshots is the list of snapshots of the application instance.\nIt is used to synchronize the list of snapshots between the controller and\nthe device. This can be used to provide an id of a new snapshot or to\ndelete an existing snapshot.\nTo provide a new snapshot id, the controller should send a message with\nthe new snapshot id in the snapshots list. The id is generated by\nController in this case. (It can be also generated by EVE, if the snapshot\ncreation is triggered locally. In this case the ID will be returned in the\nZInfoApp.snapshots[].id field, see the `info.proto` file).\nWorth noting that the snapshot creation is not triggered by the appearance\nof the snapshot id in the available_snapshots list. The snapshot creation\nwill be triggered by the behaviour defined in the snapshot type field.\nTo delete a snapshot, the controller should send a message that does not\ncontain the snapshot id in the available_snapshots list. The device will\ndelete the snapshot with the absent id."
                }
            },
            "title": "The snapshot information for an Application Instance"
        },
        "configSnapshotDesc": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "id of the snapshot.\nThe format of the ID is a standard UUIDv4.\nShould be unique within the app instance. Generated by the Controller in\nthe case the snapshot creation is requested by the Controller, or by EVE\nin the case the snapshot creation is triggered locally.\nCorresponds to the ZInfoApp.snapshots[].id field (see the `info.proto`\nfile)."
                },
                "type": {
                    "$ref": "#/definitions/eveconfigSnapshotType",
                    "description": "type of the snapshot creation trigger."
                }
            },
            "title": "A descriptor of the snapshot instance"
        },
        "configSpanningTreeProtocol": {
            "type": "object",
            "properties": {
                "portsWithBpduGuard": {
                    "type": "string",
                    "description": "Ports matched by this adapter label (logical or shared) will have the BPDU guard enabled.\nIt makes sense to enable the guard on ports which are expected to be leafs\nand therefore not participate in STP, or where the downstream bridges are not fully\ntrusted."
                }
            },
            "description": "Configuration for the Spanning Tree Protocol (STP), which is run for switch network\ninstance when the port label matches multiple network ports."
        },
        "configSystemAdapter": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "name - Name of the Network Interface. This is the Port Name\n used in Info / Metrics / flowlog etc. Name cannot be changed.\nThis will be the Network Port name."
                },
                "freeUplink": {
                    "type": "boolean",
                    "title": "DEPRECATED by cost below"
                },
                "uplink": {
                    "type": "boolean",
                    "title": "uplink - DEPRECATED by PhysicalIO.Usage / PhysicalIO.UsagePolicy\nthis is part of the uplink group\ndeprecate: have a separate device policy object in the API"
                },
                "networkUUID": {
                    "type": "string",
                    "title": "networkUUID - attach this network config for this adapter\nif not set, depending on Usage of Adapter, would be treated as\nan L2 port"
                },
                "addr": {
                    "type": "string",
                    "description": "addr - if its static network we need ip address\nIf this is specified, networkUUID must also be specified. addr\nis expected to be in sync with the network object (same subnet etc )."
                },
                "alias": {
                    "type": "string",
                    "description": "alias - Device just reflects it back in status / Metrics back to\ncloud."
                },
                "lowerLayerName": {
                    "type": "string",
                    "description": "lowerLayerName - For example, if lower layer is PhysicalAdapter\n( physical interface), this should point to logicallabel of the\nphysicalIO."
                },
                "cost": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Cost of sending traffic over the port.\nUsed to prioritize ports and give preference to lower-cost ports (e.g. eth over wwan).\n0 is the lowest cost (free); 255 the highest.\nCan be set for management and app-shared ports.\nCost is used for EVE management traffic and for local network instances with multiple\nports. For any request towards the controller or for an image download, EVE tries ports\nin the order of increasing cost, starting with the free ports. Once it finds the lowest\ncost port with a working connectivity, it may spread the load if there are multiple\nconnected ports of the same cost.\nFor local networking instances with multiple ports, the cost may be used to decide\nwhich port to use for a particular destination network (incl. port selection for\nthe default route). Unlike the management traffic, load-balancing is currently\nnot supported for local network instances and the app traffic that is routed through\nthem."
                },
                "sharedLabels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "title": "A set of user-defined \"shared\" labels attached to the adapter.\nThere are no restrictions on the format of an adapter label, it can be any\nnon-empty string.\nUnlike the logical label (aka port logical name), shared label is not a unique\nport identifier. Instead, the same shared label can be assigned to multiple ports.\nNote that EVE automatically assigns \"all\" label to every port, \"uplink\" label to every\nmanagement port and \"freeuplink\" label to every management port with zero cost.\n(\"automatically assigns\" is meant here in imaginary sense, these labels are not supposed\nto be explicitly added by the controller to SystemAdapters inside EdgeDevConfig).\nShared label can be used to:\n - designate a group of network adapters to be used by a network instances for external\n   connectivity\n - limit port-forwarding firewall rule to only a subset of network adapters\n - create a multi-path static IP route (with multiple ports providing access to the routed\n   destination network)"
                },
                "allowLocalModifications": {
                    "type": "boolean",
                    "description": "Allow the local operator to make (limited) configuration changes to this network adapter."
                }
            },
            "description": "systemAdapters are higher-level IP-ready network endpoints.\nsystemAdapters give all the required bits to turn the physical IOs\nand intermediate L2 objects into useful IP endpoints.\nThese endpoints can be further used to connect to controller or\ncan be shared between workload/services running on the node."
        },
        "configTarget": {
            "type": "string",
            "enum": [
                "TgtUnknown",
                "Disk",
                "Kernel",
                "Initrd",
                "RamDisk",
                "AppCustom"
            ],
            "default": "TgtUnknown"
        },
        "configUUIDandVersion": {
            "type": "object",
            "properties": {
                "uuid": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            }
        },
        "configVfList": {
            "type": "object",
            "properties": {
                "vfCount": {
                    "type": "integer",
                    "format": "int64",
                    "title": "how many Virtual Functions (VF) will be created"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configEthVF"
                    },
                    "title": "optional configuration for given Virtual Function (VF)"
                }
            }
        },
        "configVlanAccessPort": {
            "type": "object",
            "properties": {
                "vlanId": {
                    "type": "integer",
                    "format": "int64",
                    "title": "VLAN ID from the range <1,4094>"
                },
                "accessPort": {
                    "type": "string",
                    "description": "Physical network adapter used as the access port for the given VLAN.\nEither a single NI port referenced by its name (SystemAdapter.Name, aka logical label)\nor an adapter shared-label matching zero or more NI ports."
                }
            },
            "description": "VLAN Access Port config applied to physical port(s) attached to a Switch Network Instance."
        },
        "configVlanAdapter": {
            "type": "object",
            "properties": {
                "logicallabel": {
                    "type": "string",
                    "description": "Logical name of this VLAN adapter."
                },
                "interfaceName": {
                    "type": "string",
                    "description": "A physical name of the VLAN sub-interface.\nNote that the interface name is limited in Linux kernel to 15 characters.\nIf not defined, logicallabel will be used instead."
                },
                "lowerLayerName": {
                    "type": "string",
                    "description": "Logical name of the lower layer adapter (bond or physicalIO)."
                },
                "vlanId": {
                    "type": "integer",
                    "format": "int64",
                    "description": "VLAN ID. Valid values are from 1 to 4094."
                }
            },
            "description": "VlanAdapter represents a single VLAN sub-interface.\nThe parent, which is referenced by lower_layer_name,\nshould be either PhysicalIO or BondAdapter."
        },
        "configVmBootMode": {
            "type": "string",
            "enum": [
                "VM_BOOT_MODE_UNSPECIFIED",
                "VM_BOOT_MODE_LEGACY",
                "VM_BOOT_MODE_UEFI"
            ],
            "default": "VM_BOOT_MODE_UNSPECIFIED",
            "title": "Boot mechanisms supported by the BIOS of the Virtual Machine"
        },
        "configVmConfig": {
            "type": "object",
            "properties": {
                "kernel": {
                    "type": "string"
                },
                "ramdisk": {
                    "type": "string"
                },
                "memory": {
                    "type": "integer",
                    "format": "int64",
                    "title": "in kbytes; rounded up to Mbytes for xen"
                },
                "maxmem": {
                    "type": "integer",
                    "format": "int64",
                    "title": "in kbytes; xen only, default equal to 'memory', so no ballooning"
                },
                "vcpus": {
                    "type": "integer",
                    "format": "int64",
                    "description": "The amount of the VCPUs in the VM."
                },
                "maxcpus": {
                    "type": "integer",
                    "format": "int64",
                    "description": "In the case of the Xen hypervisor - the maximal amount of the VCPUs\navailable to the VM. Can be greater than `vcpus` (the VCPUs online on the\nVM start). If the field is not set, it is initialized by EVE to the value\nin the `vcpus` field."
                },
                "rootdev": {
                    "type": "string"
                },
                "extraargs": {
                    "type": "string"
                },
                "bootloader": {
                    "type": "string"
                },
                "cpus": {
                    "type": "string",
                    "description": "Currently is not handled by EVE.\nCPU mask of the CPUs assigned to the VM. Represented in the form\n\"d[[,-]d]*\". E.g. \"0-2\" or \"0-2,5,6\". CPUs start with 0. For example, the\nmask \"0,3\" would mean that only physical CPUs 0 and 3 are available for\nthe VM."
                },
                "devicetree": {
                    "type": "string"
                },
                "dtdev": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "irqs": {
                    "type": "array",
                    "items": {
                        "type": "integer",
                        "format": "int64"
                    }
                },
                "iomem": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "virtualizationMode": {
                    "$ref": "#/definitions/configVmMode"
                },
                "enableVnc": {
                    "type": "boolean",
                    "title": "Enable VNC access to the edge application"
                },
                "vncDisplay": {
                    "type": "integer",
                    "format": "int64"
                },
                "vncPasswd": {
                    "type": "string"
                },
                "disableLogs": {
                    "type": "boolean",
                    "title": "Change of the 'disable logs' field can be handled without VM reboot"
                },
                "pinCpu": {
                    "type": "boolean",
                    "description": "Set if the VM should run in a mode with pinned CPUs.\nIn this case any VCPU thread created by QEMU runs on a dedicated physical\nCPU. All the other QEMU threads will be limited to run on the physical\nCPUs defined by CPU mask. The CPU mask is provided with the 'cpus' field,\ndefined above. If the CPU mask is not set, the physical CPUs to be used\nfor running QEMU threads are picked automatically by Pillar: it just takes\nthat amount of available physical CPUs that is defined with the 'vcpus'\nparameter defined above."
                },
                "vmmMaxmem": {
                    "type": "integer",
                    "format": "int64",
                    "title": "Maximum amount of memory in kbytes allowed for VM monitor to occupy,\naka \"overhead\". E.g. for the qemu-kvm hypervisor the memory limit\nfor one VM instance (guest RAM + VM monitor) is set according to the\nfollowing equation: `memory` + `vmm_maxmem`"
                },
                "enableVncShimVm": {
                    "type": "boolean",
                    "title": "Enable VNC access to the shim VM harboring the edge application (for containers only)"
                },
                "bootMode": {
                    "$ref": "#/definitions/configVmBootMode",
                    "title": "Boot mode: Legacy or UEFI"
                },
                "enforceNetworkInterfaceOrder": {
                    "type": "boolean",
                    "description": "Enables enforcement of user-defined ordering for network interfaces.\nThis applies to both virtual interfaces (specified in the \"AppInstanceConfig.interfaces\" list)\nand directly assigned network adapters (specified in the \"AppInstanceConfig.adapters\" list\nas items of type \"PhyIoNetEth\", \"PhyIoNetWLAN\", \"PhyIoNetWWAN\", and \"PhyIoNetEthVF\").\nNote: Older versions of EVE may not support enforcing the user-defined order\nof application network interfaces. The controller can check\n\"ZInfoDevice.api_capability\" to verify if the configured device supports the\nAPI capability \"API_CAPABILITY_ENFORCED_NET_INTERFACE_ORDER\".\nPlease beware that EVE's ability to influence the order of VM application interfaces\nis limited. Depending on the application's operating system, achieving the desired network\ninterface order might not be possible."
                },
                "enableOemWinLicenseKey": {
                    "type": "boolean",
                    "title": "The app should receive the Windows license embedded in ACPI tables"
                },
                "disableVtpm": {
                    "type": "boolean",
                    "description": "Disable vTPM for the VM, this defaults to false according to the\nproto3 specification."
                }
            }
        },
        "configVmMode": {
            "type": "string",
            "enum": [
                "PV",
                "HVM",
                "Filler",
                "FML",
                "NOHYPER",
                "LEGACY"
            ],
            "default": "PV",
            "description": "For now we need to tell the device which virtualization mode\nto use. Later we might use a single one for all VMs (on any particular\nISA). If we end up keeping this we should make the names be less\ntied to a particular hypervisor."
        },
        "configVolume": {
            "type": "object",
            "properties": {
                "uuid": {
                    "type": "string"
                },
                "origin": {
                    "$ref": "#/definitions/configVolumeContentOrigin",
                    "description": "origin of the volume content."
                },
                "protocols": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configVolumeAccessProtocols"
                    },
                    "title": "describes all the different ways how this Volume can\nbe offered to Tasks"
                },
                "generationCount": {
                    "type": "string",
                    "format": "int64",
                    "title": "change in generationCount indicates that the mutated volume needs to be\npurged and built from scratch. This is a generalization of the purge\ncommand for an application instance"
                },
                "maxsizebytes": {
                    "type": "string",
                    "format": "int64",
                    "description": "miscellaneous attributes of the Volume\nmaxSizeBytes Used for capping resource consumption in EVE.\nmaxSizeBytes indicates the maximum size of the volume."
                },
                "readonly": {
                    "type": "boolean"
                },
                "displayName": {
                    "type": "string"
                },
                "clearText": {
                    "type": "boolean"
                },
                "target": {
                    "$ref": "#/definitions/configTarget"
                },
                "designatedNodeId": {
                    "type": "string",
                    "title": "To inform the edge-node if the device receiving this Volume is\nresponsible for volume creation, convert PVC, or not"
                }
            },
            "description": "The Volume describes a storage volume which should exist on the device.\nThis can currently either be blank or created from a ContentTree\nIf maxSizeBytes is zero it means unlimited by the controller. In that\ncase EVE needs to determine how much space it can assign and limit any\ndownloaded ContentTree and the created volume based on that calculated size."
        },
        "configVolumeAccessProtocols": {
            "type": "string",
            "enum": [
                "VAP_NONE",
                "VAP_9P"
            ],
            "default": "VAP_NONE",
            "title": "The protocol that the task will use to access the Volume"
        },
        "configVolumeContentOrigin": {
            "type": "object",
            "properties": {
                "type": {
                    "$ref": "#/definitions/configVolumeContentOriginType"
                },
                "downloadContentTreeID": {
                    "type": "string"
                }
            }
        },
        "configVolumeContentOriginType": {
            "type": "string",
            "enum": [
                "VCOT_UNKNOWN",
                "VCOT_BLANK",
                "VCOT_DOWNLOAD"
            ],
            "default": "VCOT_UNKNOWN"
        },
        "configVolumeRef": {
            "type": "object",
            "properties": {
                "uuid": {
                    "type": "string"
                },
                "generationCount": {
                    "type": "string",
                    "format": "int64"
                },
                "mountDir": {
                    "type": "string",
                    "title": "Indicates volume mount point inside container\nif mount_dir is empty then it will be mounted on /mnt"
                }
            },
            "title": "Reference to a Volume specified separately in the API\nIf a volume is purged (re-created from scratch) it will either have a new\nUUID or a new generationCount"
        },
        "configWifiConfig": {
            "type": "object",
            "properties": {
                "wifiSSID": {
                    "type": "string"
                },
                "keyScheme": {
                    "$ref": "#/definitions/commonWiFiKeyScheme"
                },
                "identity": {
                    "type": "string",
                    "title": "to be deprecated, use cipherData instead"
                },
                "password": {
                    "type": "string",
                    "title": "to be deprecated, use cipherData instead"
                },
                "crypto": {
                    "$ref": "#/definitions/WifiConfigcryptoblock"
                },
                "priority": {
                    "type": "integer",
                    "format": "int32"
                },
                "cipherData": {
                    "$ref": "#/definitions/commonCipherBlock"
                }
            }
        },
        "configWirelessConfig": {
            "type": "object",
            "properties": {
                "type": {
                    "$ref": "#/definitions/evecommonWirelessType"
                },
                "cellularCfg": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configCellularConfig"
                    }
                },
                "wifiCfg": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/configWifiConfig"
                    }
                }
            }
        },
        "configZNetworkInstType": {
            "type": "string",
            "enum": [
                "ZNetInstFirst",
                "ZnetInstSwitch",
                "ZnetInstLocal",
                "ZnetInstCloud",
                "ZnetInstMesh",
                "ZnetInstHoneyPot",
                "ZnetInstTransparent",
                "ZNetInstLast"
            ],
            "default": "ZNetInstFirst"
        },
        "configZNetworkOpaqueConfigType": {
            "type": "string",
            "enum": [
                "ZNetOConfigVPN",
                "ZNetOConfigLisp"
            ],
            "default": "ZNetOConfigVPN"
        },
        "configZcServicePoint": {
            "type": "object",
            "properties": {
                "zsType": {
                    "$ref": "#/definitions/configZcServiceType"
                },
                "NameOrIp": {
                    "type": "string"
                },
                "Credential": {
                    "type": "string"
                }
            },
            "title": "This is way to tell the device if there is service in cloud somewhere,\nwhat type it is how to access it"
        },
        "configZcServiceType": {
            "type": "string",
            "enum": [
                "zcloudInvalidSrv",
                "mapServer",
                "supportServer"
            ],
            "default": "zcloudInvalidSrv",
            "title": "- mapServer: mapping service for zededa overlay service\n - supportServer: if device has support feature enabled, this is cloud service from\ndevice can be reached"
        },
        "evecommonCellularAuthProtocol": {
            "type": "string",
            "enum": [
                "CELLULAR_AUTH_PROTOCOL_NONE",
                "CELLULAR_AUTH_PROTOCOL_PAP",
                "CELLULAR_AUTH_PROTOCOL_CHAP",
                "CELLULAR_AUTH_PROTOCOL_PAP_AND_CHAP"
            ],
            "default": "CELLULAR_AUTH_PROTOCOL_NONE",
            "description": "CellularAuthProtocol defines the authentication protocol used for cellular connection.\n\n - CELLULAR_AUTH_PROTOCOL_NONE: No authentication.\n - CELLULAR_AUTH_PROTOCOL_PAP: Password Authentication Protocol.\n - CELLULAR_AUTH_PROTOCOL_CHAP: Challenge-Handshake Authentication Protocol.\n - CELLULAR_AUTH_PROTOCOL_PAP_AND_CHAP: Both PAP and CHAP."
        },
        "evecommonDiskDescription": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                },
                "logicalName": {
                    "type": "string"
                },
                "serial": {
                    "type": "string"
                }
            },
            "title": "DiskDescription describes disk\nwe can use different data to locate disk in the system"
        },
        "evecommonRadioAccessTechnology": {
            "type": "string",
            "enum": [
                "RADIO_ACCESS_TECHNOLOGY_UNSPECIFIED",
                "RADIO_ACCESS_TECHNOLOGY_GSM",
                "RADIO_ACCESS_TECHNOLOGY_UMTS",
                "RADIO_ACCESS_TECHNOLOGY_LTE",
                "RADIO_ACCESS_TECHNOLOGY_5GNR"
            ],
            "default": "RADIO_ACCESS_TECHNOLOGY_UNSPECIFIED",
            "description": " - RADIO_ACCESS_TECHNOLOGY_GSM: Global System for Mobile Communications (2G).\n - RADIO_ACCESS_TECHNOLOGY_UMTS: Universal Mobile Telecommunications System (3G).\n - RADIO_ACCESS_TECHNOLOGY_LTE: Long Term Evolution (4G).\n - RADIO_ACCESS_TECHNOLOGY_5GNR: 5G New Radio."
        },
        "evecommonWirelessType": {
            "type": "string",
            "enum": [
                "TypeNOOP",
                "WiFi",
                "Cellular"
            ],
            "default": "TypeNOOP"
        },
        "eveconfigClusterType": {
            "type": "string",
            "enum": [
                "CLUSTER_TYPE_UNSPECIFIED",
                "CLUSTER_TYPE_K3S_BASE",
                "CLUSTER_TYPE_REPLICATED_STORAGE",
                "CLUSTER_TYPE_HA"
            ],
            "default": "CLUSTER_TYPE_UNSPECIFIED"
        },
        "eveconfigEdgeNodeCluster": {
            "type": "object",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "title": "cluster name, in case it has multiple cluster on the same site"
                },
                "clusterId": {
                    "type": "string",
                    "title": "cluster UUID"
                },
                "clusterInterface": {
                    "type": "string",
                    "title": "Cluster-Interface, for example \"mgmt0\", this is the logicallabel of the physicalIO"
                },
                "clusterIpPrefix": {
                    "type": "string",
                    "title": "the 'cluster-prefix' IP address of the 'Cluster-Interface', 10.244.244.2/28"
                },
                "isWorkerNode": {
                    "type": "boolean",
                    "title": "This device is an 'Agent' node"
                },
                "joinServerIp": {
                    "type": "string",
                    "title": "Server IP address to join the cluster. E.g. 10.244.244.1"
                },
                "encryptedClusterToken": {
                    "$ref": "#/definitions/commonCipherBlock",
                    "title": "encrypted token string, use edge-node TPM to decrypt"
                },
                "clusterType": {
                    "$ref": "#/definitions/eveconfigClusterType",
                    "title": "Cluster Type for eve to determine component, app, and volume scheduling needs"
                },
                "tieBreakerNodeId": {
                    "type": "string",
                    "description": "Node Id for eve to disable all pod scheduling\nEVE-OS should use this to set kubernetes node labels identifying\nthe tie-breaker node to the kubernetes scheduler.\nNode labels are used in the node selector specification of\nkubernetes objects to direct pod scheduling away from a\nspecific node due to node limitations."
                }
            }
        },
        "eveconfigExternalOpaqueBinaryBlob": {
            "type": "object",
            "properties": {
                "imageName": {
                    "type": "string",
                    "title": "Name of the image uploaded into data store"
                },
                "fileNameToUse": {
                    "type": "string",
                    "title": "file name to be used for storing this data in EVE\nthe same file name shall be advertised to application agent\nif it's empty EVE will use image name"
                },
                "blobMetaData": {
                    "type": "string",
                    "title": "can be image type or size encoded into a single string"
                },
                "imageId": {
                    "type": "string",
                    "title": "Target field of Volume set to AppCustom\nrefers to UUID of a volume"
                }
            }
        },
        "eveconfigIPRoute": {
            "type": "object",
            "properties": {
                "destinationNetwork": {
                    "type": "string",
                    "description": "Destination network address in the CIDR format: <IP-address>/<prefix-length>\nIt is allowed to submit default route with all-zeroes destination network address\n0.0.0.0/0 or ::/0."
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway IP address.\nThis must be a valid IP address and can not be all-zeroes.\nAt least one of 'gateway' or 'port' (see below) must be defined (both can be set).\nThis can be an external gateway IP or an IP address of one of the app instances\nconnected to the network instance."
                },
                "port": {
                    "type": "string",
                    "description": "Output device port for the routed traffic.\nEither a single NI port referenced by its name (SystemAdapter.Name, aka logical label)\nor an adapter shared-label matching zero or more NI ports (multipath routing).\nCan be used additionally to or instead of `gateway` to determine the next hop\nand the output network interface for the destination network.\nAt least one of 'gateway' or 'port' must be defined.\nSince 'port' refers to one or more physical network adapters, it is not applicable\nto routes where gateway points to another application instance running on EVE.\nIf shared label is used, EVE will pick (at most) one of the matched ports to be used\nfor route at a given time. Port is selected based on connectivity status, port costs,\nwwan signal strength, etc. - see config options below.\nNote that load-balancing across multiple ports is not yet supported.\nAlso please note that if `gateway` is defined, only ports with subnets containing\nthe gateway IP will be considered."
                },
                "probe": {
                    "$ref": "#/definitions/configPortProbe",
                    "description": "Periodically probe remote endpoint to determine connectivity status of every port\nselected for the route (by the 'port' label, see above). One of the ports with\na working connectivity is then picked for the route. If there are multiple connected\nports, other port selection criteria are considered (port costs, wwan signal strength,\netc., see other options of IPRoute).\nProbing effectively provides automatic fail-over between ports.\nIf 'port' is not defined or references only a single port (e.g. directly by\nthe logical label), probing is skipped (nothing to fail-over to anyway).\nIf probing is not enabled, EVE picks the port based on other remaining criteria,\nsuch as cost, wwan network signal, etc. (and eventually possibly making a random\nchoice)."
                },
                "preferLowerCost": {
                    "type": "boolean",
                    "description": "When EVE is deciding which port to use for multipath route and multiple ports have\nworking connectivity (or probing is disabled), port can be selected based on the cost\n(see SystemAdapter.cost). If this option is enabled, EVE will prefer ports with lower\ncosts."
                },
                "preferStrongerWwanSignal": {
                    "type": "boolean",
                    "description": "When EVE is deciding which port to use for multipath route and there are multiple\ncandidates among cellular modems, it might make sense to consider the current cellular\nnetwork signal strength. If this option is enabled, EVE will prefer cellular ports\nwith better signal (only among cellular ports)."
                }
            }
        },
        "eveconfigImage": {
            "type": "object",
            "properties": {
                "uuidandversion": {
                    "$ref": "#/definitions/configUUIDandVersion"
                },
                "name": {
                    "type": "string",
                    "title": "it could be relative path/name as well; appended to the datastore dpath"
                },
                "sha256": {
                    "type": "string"
                },
                "iformat": {
                    "$ref": "#/definitions/configFormat"
                },
                "siginfo": {
                    "$ref": "#/definitions/configSignatureInfo",
                    "title": "if its signed image"
                },
                "dsId": {
                    "type": "string"
                },
                "sizeBytes": {
                    "type": "string",
                    "format": "int64",
                    "description": "sizeBytes indicates the maximum download size of an image.\nA value of 0 will indicate the unlimited download."
                }
            },
            "title": "XXX the Image will be deprecated and we will use ContentTree instead"
        },
        "eveconfigInlineOpaqueBase64Data": {
            "type": "object",
            "properties": {
                "base64Data": {
                    "type": "string",
                    "title": "base64 encoded data"
                },
                "fileNameToUse": {
                    "type": "string",
                    "title": "file name to be used for storing this data\nsame file name shall be advertised to application agent"
                },
                "base64MetaData": {
                    "type": "string",
                    "title": "any arbitraty metadata encoded to base64 string"
                }
            }
        },
        "eveconfigSnapshotType": {
            "type": "string",
            "enum": [
                "SNAPSHOT_TYPE_UNSPECIFIED",
                "SNAPSHOT_TYPE_APP_UPDATE",
                "SNAPSHOT_TYPE_IMMEDIATE"
            ],
            "default": "SNAPSHOT_TYPE_UNSPECIFIED",
            "title": "Type of the snapshot creation trigger"
        },
        "googlerpcStatus": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "format": "int32"
                },
                "message": {
                    "type": "string"
                },
                "details": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protobufAny"
                    }
                }
            }
        },
        "protobufAny": {
            "type": "object",
            "properties": {
                "typeUrl": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "format": "byte"
                }
            }
        },
        "protobufNullValue": {
            "type": "string",
            "enum": [
                "NULL_VALUE"
            ],
            "default": "NULL_VALUE",
            "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\n The JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
        }
    },
    "securityDefinitions": {
        "BearerToken": {
            "type": "apiKey",
            "description": "Bearer token for user session",
            "name": "Authorization",
            "in": "header"
        }
    },
    "security": [
        {
            "BearerToken": []
        }
    ],
    "externalDocs": {
        "description": "ZEDEDA Product Documentation",
        "url": "https://help.zededa.com/hc/en-us/articles/30323173611931-ZEDEDA-API-Overview"
    }
}